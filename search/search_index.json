{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"Note to the reader: <p>This library is very much a work in progress, as is the documentation. Naturally, the contents of this library is subject to change depending on choice of research avenue. At the moment, there exists a solid basis on which to build, but the API may change to improve accessiblity for new users. If there is anything you would like to see in the library, or anything you think that needs to change -- please do let me know.</p> <p>Riemax is a JAX library for Riemannian geometry, providing the ability to define induced metrics and operate on manifolds directly. This includes functionality, such as:</p> <ul> <li>Computing geometric quantities on manifolds.</li> <li>Defining operators on manifolds.</li> <li>Tools for geometric statistics.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/danielkelshaw/riemax\n</code></pre> <p>Requires Python 3.11+ and JAX 0.4.13+.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Manifolds can be defined by a function transformation, \\(\\iota: M \\rightarrow N\\):</p> <pre><code>import riemax as rx\n\nfn_transformation = rx.fn_transformations.fn_peaks\nmanifold = rx.Manifold.from_fn_transformation(fn_transformation)\n</code></pre> <p>and can be used to compute properties on the manifold:</p> <p><pre><code>import jax\nimport jax.numpy as jnp\n\np = jnp.array([0.0, 0.0])\n\nmetric = manifold.metric_tensor(p)\nchristoffel = manifold.sk_christoffel(p)\nricci_scalar = manifold.ricci_scalar(p)\n</code></pre> We can also define operators. Given a function \\(f: M \\rightarrow \\mathbb{R}\\):</p> <pre><code>from riemax.manifold import M, Rn\n\ndef f(p: M[jax.Array]) -&gt; Rn[jax.Array]:\n    return jnp.einsum('i -&gt; ', p ** 2)\n\nfn_grad = manifold.grad(f)\n\n# we can define the laplacian explicitly:\nfn_laplacian = manifold.div(fn_grad)\n\n# ... or from manifold:\nfn_laplacian = manifold.laplace_beltrami(f)\n</code></pre> <p>We can exploit the ability to compute geometric quantities to compute the exponential map:</p> <pre><code>dt = 1e-3\nn_steps = int(1.0 // dt)\n\nfn_exp_map = rx.manifold.maps.exponential_map_factory(\n    integrator=rx.numerical.integrators.odeint,\n    dt=dt,\n    metric=manifold.metric_tensor,\n    n_steps=n_steps\n)\n\np_in_tm = rx.manifold.TangentSpace(p, jnp.array([1.0, 1.0]))\nq_in_tm, trajectory = fn_exp_map(p_in_tm)\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<p>The examples above show just a fraction of what is possible with Riemax. If this quick start has piqued your interest, please feel free to take a look at the examples to get a better feeling for what is possible with this library.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you found this library to be useful in academic work, then please cite:</p> <pre><code>@misc{kelshaw2023riemax\n    title = {{Riemax}: {R}iemannian geometry in {JAX} via automatic differentiation}\n    author = {Daniel Kelshaw}\n    year = {2023},\n    url = {https://github.com/danielkelshaw/riemax}\n}\n</code></pre>"},{"location":"#see-also-other-libraries-in-the-jax-ecosystem","title":"See also: other libraries in the JAX ecosystem:","text":"<p>Optax: first-order gradient (SGD, Adam, ...) optimisers.</p> <p>Haiku: neural network library.</p> <p>Equinox: neural networks.</p> <p>Diffrax: numerical differential equation solvers.</p>"},{"location":"examples/curvature_sampling/","title":"Curvature-based Sampling","text":"<pre><code>import typing as tp\n\nimport riemax as rx\n\nimport einops\n\nimport jax\nimport jax.numpy as jnp\nimport jax.tree_util as jtu\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm, colors\nfrom mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n\njax.config.update('jax_platform_name', 'cpu')\n</code></pre> <pre><code>key = jax.random.PRNGKey(42)\n\nfn_transformation = rx.fn_transformations.fn_peaks\nmanifold = rx.Manifold.from_fn_transformation(fn_transformation)\n</code></pre> <pre><code>@jax.jit\ndef compute_curvature(x: jax.Array) -&amp;gt; jax.Array:\n    return jnp.abs(manifold.ricci_scalar(x))\n</code></pre> <pre><code>x_initial = jnp.array([0.0, 0.0])\n\npos, do_accept = jax.vmap(rx.numerical.sampling.rwmh_sampler, in_axes=(0, None, None, None))(\n    jax.random.split(key, num=5),\n    int(5e4),\n    compute_curvature,\n    x_initial,\n)\n\naccepted_pos = pos[do_accept]\n</code></pre> <pre><code>def generate_coordinate_grid(fn: tp.Callable[[jax.Array], jax.Array], n_points: int, limits: tuple[int, int]) -&amp;gt; jax.Array:\n\n    d = jnp.linspace(*limits, n_points)\n    coords = jnp.array([*jnp.meshgrid(d, d, indexing='ij')]).T\n\n    flat_coords = einops.rearrange(coords, 'i j n -&amp;gt; (i j) n')    \n    euc_coords = einops.rearrange(jax.vmap(fn)(flat_coords), '(i j) n -&amp;gt; i j n', i=n_points)\n\n    return euc_coords\n\nn_points = 1000\neuc_coords = generate_coordinate_grid(fn_transformation, n_points=n_points, limits=[-3.0, 3.0])\n\nr_field = jax.vmap(jax.vmap(manifold.ricci_scalar))(euc_coords[..., :2])\n</code></pre> <p>Finally, we plot the samples on the manifold:</p> <pre><code>fig = plt.figure(figsize=(12, 10))\nax = fig.gca()\n\n# plot shape of manifold\nax.contour(*euc_coords.T, levels=50, alpha=0.6, colors='k', linewidths=0.8)\n\n# plot colourmap of ricci scalar\nim = ax.imshow(jnp.abs(r_field), cmap=cm.Purples, extent=(-3, 3, -3, 3), origin='lower', alpha=1.0, norm=colors.LogNorm(1e-1, vmax=r_field.max()))\n\ndivider = make_axes_locatable(ax)\ncax = divider.append_axes('right', size='5%', pad=0.05)\ncbar = fig.colorbar(im, cax=cax)\n\n# plot random samples\n_samples = jax.random.choice(key, accepted_pos, shape=(5000,))\nax.scatter(*_samples.T, c='k', marker='.', s=5, alpha=0.6)\n\n# configure plot\nax.set_aspect('equal')\n\nax.set_xlim(-3, 3)\nax.set_ylim(-3, 3)\n</code></pre> <pre>\n<code>(-3.0, 3.0)</code>\n</pre>"},{"location":"examples/curvature_sampling/#curvature-based-sampling","title":"Curvature-based Sampling:","text":"<p>With the ability to compute the Ricci scalar on arbitrary differentiable manifolds, we can draw random samples on the manifold correlated to the scalar curvature. We show this by employing the Metropolis-Hastings algorithm to generate samples in regions exhibiting higher-degrees of scalar curvature.</p>"},{"location":"examples/curvature_sampling/#defining-the-manifold","title":"Defining the Manifold:","text":""},{"location":"examples/curvature_sampling/#metropolis-hastings-sampling","title":"Metropolis-Hastings Sampling:","text":"<p>We will conduct Metropolis-Hastings sampling with 5 independant chains:</p>"},{"location":"examples/curvature_sampling/#visualisation","title":"Visualisation","text":"<p>We generate a grid on which to visualise the manifold, and the Ricci scalar:</p>"},{"location":"examples/introduction/","title":"Introduction to Riemax","text":"<pre><code>import riemax as rx\n\nfn_transformation = rx.fn_transformations.fn_peaks\nmanifold = rx.Manifold.from_fn_transformation(fn_transformation)\n</code></pre> <p>Our newly created manifold allows us to compute quantities of interest on the manifold. We first define a point \\(p \\in M\\), and vectors \\(v, w \\in T_p M\\)</p> <pre><code>from riemax.manifold.types import M, TpM, Rn\n\nimport jax\nimport jax.numpy as jnp\n\n\n# defining a point p on the manifold\np: M[jax.Array] = jnp.array([0.0, 0.0])\n\n# defining vectors at p\nv: TpM[jax.Array] = jnp.array([1.0, 0.0])\nw: TpM[jax.Array] = jnp.array([0.0, 1.0])\n</code></pre> <p>Now, we can compute our quantities of interest</p> <pre><code>metric_at_p = manifold.metric_tensor(p)\nchristoffel_symbols_at_p = manifold.sk_christoffel(p)\n\ninner_product = manifold.inner_product(p, v, w)\n</code></pre> <pre><code>import typing as tp\n\ndef produce_coordinate_grid(fn: tp.Callable[[M[jax.Array]], Rn[jax.Array]], n_points: int) -&amp;gt; Rn[jax.Array]:\n\n    _x = jnp.linspace(-3.0, 3.0, n_points)\n    grid = jnp.stack(jnp.meshgrid(_x, _x), axis=-1)\n\n    return jax.vmap(jax.vmap(fn))(grid)\n\ncoordinate_grid = produce_coordinate_grid(fn_transformation, n_points=100)\n</code></pre> <p>Next, we compute the magnification factor at each point in the domain</p> <pre><code>magnification_factor = jax.vmap(jax.vmap(manifold.magnification_factor))(coordinate_grid[..., :2])\n</code></pre> <p>Finally, we produce a plot to demonstrate the computed values</p> <pre><code>from matplotlib import cm, colors\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable\n\nfig = plt.figure(figsize=(12, 10))\nax = fig.gca()\n\nplt_kwargs = dict(origin='lower', extent=(-3.0, 3.0, -3.0, 3.0))\n\n# plot the geometry of the surface\nax.contour(*coordinate_grid.T, levels=50, alpha=0.6, colors='k', linewidths=0.8, **plt_kwargs)\n\n# plot the magnification factor at each point\nim = ax.contourf(magnification_factor, levels=100, cmap=cm.Purples, **plt_kwargs)\n\ndivider = make_axes_locatable(ax)\ncax = divider.append_axes('right', size='5%', pad=0.05)\ncbar = fig.colorbar(im, cax=cax)\n\n# configure plot\nax.set_aspect('equal')\n\nax.set_xlim(-3, 3)\nax.set_ylim(-3, 3)\n</code></pre> <pre>\n<code>(-3.0, 3.0)</code>\n</pre>"},{"location":"examples/introduction/#introduction","title":"Introduction","text":"<p>A Riemannian manifold is a pair \\((M, g)\\), where \\(M\\) is a smooth manifold, and \\(g\\) is a choice of Riemannian metric on \\(M\\). This metric constitutes a symmetric bilinear form \\(g: T_p M \\times T_p M \\rightarrow \\mathbb{R}\\), allowing for computation of the inner product on the tangent space. Given a point \\(p \\in M\\) and vectors \\(v, w \\in T_p M\\), we define the inner product as </p> \\[ \\langle v, w \\rangle_g = g_p(v, w) = g_{ij} v^i w^j. \\] <p>We first consider the case of embedded submanifolds. Suppose \\((\\tilde{M}, \\tilde{g})\\) is a Riemannian manifold, and \\(M \\subseteq \\tilde{M}\\) is an embedded manifold. Given a smooth immersion \\(\\iota: M \\hookrightarrow \\tilde{M}\\), the metric \\(g = \\iota^\\ast g\\) is reffered to as the metric induced by \\(\\iota\\), where \\(\\iota^\\ast\\) is the pullback. If \\((M, g)\\) is a Riemannian submanifold of \\((\\tilde{M}, \\tilde{g})\\), then for every \\(p \\in M\\) and \\(v, w \\in T_p M\\), the induced metric is defined as</p> \\[ g_p(v, w) = (\\iota^\\ast \\tilde{g})_p (v, w) = \\tilde{g}_{\\iota(p)} (d\\iota_p(v), d\\iota_p(w)). \\] <p>In this example, we show how we can produce such an induced metric and use it to compute quantities of interest on the manifold.</p>"},{"location":"examples/introduction/#defining-the-manifold","title":"Defining the Manifold","text":"<p>We first define our function transformation, \\(\\iota: M \\rightarrow \\mathbb{R}^3\\) and build the manifold.</p>"},{"location":"examples/introduction/#showcasing-the-magnification-factor","title":"Showcasing the Magnification Factor","text":"<p>We can visualise something like the magnification factor across the domain. First, we produce the grid on which we wish to compute the magnification factor</p>"},{"location":"manifold/","title":"Manifold","text":""},{"location":"manifold/#src.riemax.Manifold","title":"<code>src.riemax.Manifold</code>","text":"<p>Convenience class for creating a manifold.</p> <p>Note</p> <p>Riemax remains a functional library, and all functionality has been defined in a pure manner. The <code>Manifold</code> class ties together relevant functionlity, automatically creating partial applications of functions so the user need not pass the metric function around all the time.</p> <p>This class is defined dynamically, using decorators to mark relevant functions throughout the library.</p>"},{"location":"manifold/#src.riemax.Manifold--instantiation","title":"Instantiation","text":"<p>A default <code>__init__</code> is provided, allowing the user to pass a function which computes the metric tensor on the given manifold. Alternatively, you can instantiate an <code>Manifold</code> using a function transformation:</p> <pre><code>manifold = riemax.Manifold.from_fn_transformation(...)\n</code></pre>"},{"location":"manifold/#src.riemax.Manifold--methods","title":"Methods","text":"<p>After you have defined your manifold, you have the freedom to compute quantities without passing in the metric tensor each time. Most of the time, you will be working on a single manifold, and creating partial functions can become tiresome. Instead, the <code>Manifold</code> class handles the partial applications, as well as <code>jax.jit</code>, letting you call functions naturally.</p> <p>For example you can compute geometric quantities:</p> <pre><code>metric_p = manifold.metric_tensor(p)\nriemann_tensor = manifold.sk_riemann_tensor(p)\n</code></pre> Source code in <code>src/riemax/manifold/_manifold.py</code> <pre><code>class Manifold:\n\n    \"\"\"Convenience class for creating a manifold.\n\n    !!! note\n\n        Riemax remains a functional library, and all functionality has been defined in a pure manner. The `Manifold`\n        class ties together relevant functionlity, automatically creating partial applications of functions so the user\n        need not pass the metric function around all the time.\n\n        This class is defined dynamically, using decorators to mark relevant functions throughout the library.\n\n    ### Instantiation\n\n    A default `__init__` is provided, allowing the user to pass a function which computes the metric tensor on the given\n    manifold. Alternatively, you can instantiate an `Manifold` using a function transformation:\n\n    ```python\n    manifold = riemax.Manifold.from_fn_transformation(...)\n    ```\n\n    ### Methods\n\n    After you have defined your manifold, you have the freedom to compute quantities without passing in the metric\n    tensor each time. Most of the time, you will be working on a single manifold, and creating partial functions can\n    become tiresome. Instead, the `Manifold` class handles the partial applications, as well as `jax.jit`, letting you\n    call functions naturally.\n\n    For example you can compute geometric quantities:\n\n    ```python\n    metric_p = manifold.metric_tensor(p)\n    riemann_tensor = manifold.sk_riemann_tensor(p)\n    ```\n    \"\"\"\n\n    def __new__(cls, metric: MetricFn, *, jit: bool = True) -&gt; Manifold:\n        obj = super().__new__(cls)\n        for fn, jittable in manifold_marker:\n            p_fn = jtu.Partial(fn, metric=metric)\n\n            if jittable and jit:\n                p_fn = jax.jit(p_fn)\n\n            p_fn.__doc__ = fn.__doc__\n\n            setattr(obj, fn.__name__, p_fn)\n\n        return obj\n\n    def __init__(self, metric: MetricFn, *, jit: bool = True) -&gt; None:\n        \"\"\"Instantiate a Manifold\n\n        Parameters:\n            metric: function defining the metric tensor on the manifold.\n            jit: whether to apply `jax.jit` to the functions.\n        \"\"\"\n\n        self.metric_tensor = metric\n        self.jit = jit\n\n    def __repr__(self) -&gt; str:\n        return f'Manifold(metric={self.metric_tensor.__name__})'\n\n    @classmethod\n    def from_fn_transformation(\n        cls, fn_transformation: tp.Callable[[M[jax.Array]], jax.Array], *, jit: bool = True\n    ) -&gt; Manifold:\n        \"\"\"Instantiates an induced Manifold from a function transformation.\n\n        Parameters:\n            fn_transformation: function used to define the induced metric.\n            jit: whether to apply `jax.jit` to the functions.\n        \"\"\"\n\n        p_metric = jtu.Partial(metric_tensor, fn_transformation=fn_transformation)\n        p_metric.__doc__ = metric_tensor.__doc__\n\n        return cls(metric=p_metric, jit=jit)\n</code></pre>"},{"location":"manifold/euclidean/","title":"euclidean","text":""},{"location":"manifold/euclidean/#src.riemax.euclidean","title":"<code>src.riemax.euclidean</code>","text":""},{"location":"manifold/euclidean/#src.riemax.euclidean.metric_tensor","title":"<code>src.riemax.euclidean.metric_tensor(x: jax.Array) -&gt; jax.Array</code>","text":"<p>Defines the metric tensor for Euclidean space.</p> <p>In Euclidean space, the metric tensor is defined as the identity matrix</p> \\[ g_{ij} = \\delta_{ij}. \\] <p>Warning</p> <p>The Euclidean metric defined in this manner is not differentiable. This could cause problems in some places.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>jax.Array</code> <p>position \\(p \\in \\mathbb{R}\\) at which to evaluate the metric tensor</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>metric tensor in Euclidean space -- the identity matrix</p> Source code in <code>src/riemax/manifold/euclidean.py</code> <pre><code>def metric_tensor(x: jax.Array) -&gt; jax.Array:\n    r\"\"\"Defines the metric tensor for Euclidean space.\n\n    In Euclidean space, the metric tensor is defined as the identity matrix\n\n    $$\n    g_{ij} = \\delta_{ij}.\n    $$\n\n    !!! warning\n\n        The Euclidean metric defined in this manner is not differentiable. This could cause problems in some places.\n\n    Parameters:\n        x: position $p \\in \\mathbb{R}$ at which to evaluate the metric tensor\n\n    Returns:\n        metric tensor in Euclidean space -- the identity matrix\n    \"\"\"\n\n    return jnp.eye(N=x.shape[-1])\n</code></pre>"},{"location":"manifold/euclidean/#src.riemax.euclidean.distance","title":"<code>src.riemax.euclidean.distance(p: jax.Array, q: jax.Array) -&gt; jax.Array</code>","text":"<p>Compute Euclidean distance between points.</p> <p>The Euclidean distance is simply defined by the L2 norm:</p> \\[ d_E(p, q) = \\lVert p - q \\rVert_2. \\] <p>Parameters:</p> Name Type Description Default <code>p</code> <code>jax.Array</code> <p>position \\(p \\in \\mathbb{R}\\) of the first point</p> required <code>q</code> <code>jax.Array</code> <p>position \\(q \\in \\mathbb{R}\\) of the second point</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>euclidean distance between \\(p, q\\)</p> Source code in <code>src/riemax/manifold/euclidean.py</code> <pre><code>def distance(p: jax.Array, q: jax.Array) -&gt; jax.Array:\n    r\"\"\"Compute Euclidean distance between points.\n\n    The Euclidean distance is simply defined by the L2 norm:\n\n    $$\n    d_E(p, q) = \\lVert p - q \\rVert_2.\n    $$\n\n    Parameters:\n        p: position $p \\in \\mathbb{R}$ of the first point\n        q: position $q \\in \\mathbb{R}$ of the second point\n\n    Returns:\n        euclidean distance between $p, q$\n    \"\"\"\n\n    return jnp.sqrt(jnp.einsum('...i -&gt; ...', (p - q) ** 2))\n</code></pre>"},{"location":"manifold/geodesic/","title":"geodesic","text":""},{"location":"manifold/geodesic/#riemax.manifold.geodesic","title":"<code>riemax.manifold.geodesic</code>","text":""},{"location":"manifold/geodesic/#riemax.manifold.geodesic.geodesic_dynamics","title":"<code>riemax.manifold.geodesic.geodesic_dynamics(state: TangentSpace[jax.Array], metric: MetricFn) -&gt; TangentSpace[jax.Array]</code>","text":"<p>Compute update step for the geodesic dynamics.</p> <p>The geodesic equation</p> \\[ \\ddot{\\gamma}^k + \\Gamma^k_{\\phantom{k}ij} \\dot{\\gamma}^i \\dot{\\gamma}^j  = 0 \\] <p>is a second order ordinary differential equation. We take the conventional approach of splitting this into two first-order ordinary differential equations.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>current state of the geodesic integration</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>derivatives used to compute update for the state</p> Source code in <code>src/riemax/manifold/geodesic.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef geodesic_dynamics(state: TangentSpace[jax.Array], metric: MetricFn) -&gt; TangentSpace[jax.Array]:\n    r\"\"\"Compute update step for the geodesic dynamics.\n\n    The geodesic equation\n\n    $$\n    \\ddot{\\gamma}^k + \\Gamma^k_{\\phantom{k}ij} \\dot{\\gamma}^i \\dot{\\gamma}^j  = 0\n    $$\n\n    is a second order ordinary differential equation. We take the conventional approach of splitting\n    this into two first-order ordinary differential equations.\n\n    Parameters:\n        state: current state of the geodesic integration\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        derivatives used to compute update for the state\n    \"\"\"\n\n    sk_christ = sk_christoffel(state.point, metric)\n    vector_dot = -jnp.einsum('kij, i, j -&gt; k', sk_christ, state.vector, state.vector)\n\n    return TangentSpace[jax.Array](state.vector, vector_dot)\n</code></pre>"},{"location":"manifold/geodesic/#riemax.manifold.geodesic.alternative_geodesic_dynamics","title":"<code>riemax.manifold.geodesic.alternative_geodesic_dynamics(state: TangentSpace[jax.Array], metric: MetricFn) -&gt; TangentSpace[jax.Array]</code>","text":"<p>Compute geodesic dynamics, as per (Arvanitidis, G., Hansen, LK., Hauberg, S., 2018).<sup>1</sup></p> <p>Latent Space Oddity Approach</p> <p>The paper 'Latent Space Oddity' provides a different formulation of the geodesic equation. It is not clear why this is useful or necessary, and obscures computation of the Christoffel symbols; nevertheless, an implementation is provided below.</p> <p>Interestingly, seminal papers: 'A Geometric take on Metric Learning', 'Metrics for Probabilistic Models' use a similar approach but are missing a term. It appears that these are incorrect and should likely be revised to reflect their errors.</p> <p>While the mathematical specification for the alternative dynamics makes use of <code>vec</code>, I avoid this to ensure we only have to compute the Jacobian of the metric tensor a single time.</p> <ol> <li> <p>Arvanitidis, Georgios, Lars Kai Hansen, and S\u00f8ren Hauberg. \u2018Latent Space Oddity: On the Curvature of Deep Generative Models\u2019. arXiv, 2021. http://arxiv.org/abs/1710.11379 \u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>current state of the geodesic integration</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>derivatives used to compute update for the state</p> Source code in <code>src/riemax/manifold/geodesic.py</code> <pre><code>def alternative_geodesic_dynamics(state: TangentSpace[jax.Array], metric: MetricFn) -&gt; TangentSpace[jax.Array]:\n    r\"\"\"Compute geodesic dynamics, as per (Arvanitidis, G., Hansen, LK., Hauberg, S., 2018).[^1]\n\n    !!! note \"Latent Space Oddity Approach\"\n        The paper 'Latent Space Oddity' provides a different formulation of the geodesic equation. It is not clear why\n        this is useful or necessary, and obscures computation of the Christoffel symbols; nevertheless, an\n        implementation is provided below.\n\n        Interestingly, seminal papers: 'A Geometric take on Metric Learning', 'Metrics for Probabilistic Models' use a\n        similar approach but are missing a term. It appears that these are incorrect and should likely be revised to\n        reflect their errors.\n\n        While the mathematical specification for the alternative dynamics makes use of `vec`, I avoid this to ensure we\n        only have to compute the Jacobian of the metric tensor a single time.\n\n    [^1]:\n        Arvanitidis, Georgios, Lars Kai Hansen, and S\u00f8ren Hauberg. \u2018Latent Space Oddity: On the Curvature of Deep Generative Models\u2019. arXiv, 2021. &lt;a href=\"http://arxiv.org/abs/1710.11379\"&gt;http://arxiv.org/abs/1710.11379&lt;/a&gt;\n\n    Parameters:\n        state: current state of the geodesic integration\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        derivatives used to compute update for the state\n    \"\"\"\n\n    contra_g_ij = contravariant_metric_tensor(state.point, metric)\n\n    dgdx = jax.jacobian(metric)(state.point)\n    central_term = 2.0 * einops.rearrange(dgdx, 'i j k -&gt; i (j k)') - einops.rearrange(dgdx, 'i j k -&gt; k (i j)')\n\n    vector_dot = -0.5 * contra_g_ij @ central_term @ jnp.kron(state.vector, state.vector)\n\n    return TangentSpace[jax.Array](state.vector, vector_dot)\n</code></pre>"},{"location":"manifold/geodesic/#riemax.manifold.geodesic.compute_geodesic_length","title":"<code>riemax.manifold.geodesic.compute_geodesic_length(geodesic: TangentSpace[jax.Array], dt: float, metric: MetricFn, integral_approximator: IntegralApproximationFn = mean_integration) -&gt; jax.Array</code>","text":"<p>Compute length of the geodesic.</p> <p>The length of a geodesic is defined as</p> \\[ L(\\gamma, \\dot{\\gamma}) = \\int_0^1 \\sqrt{ g_{\\gamma} (\\dot{\\gamma}, \\dot{\\gamma}) } dt. \\] <p>We note that this is not necessarily equivalent to the geodesic distance between two points.</p> <p>Parameters:</p> Name Type Description Default <code>geodesic</code> <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>point on the geodesic</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>length of the geodesic</p> Source code in <code>src/riemax/manifold/geodesic.py</code> <pre><code>def compute_geodesic_length(\n    geodesic: TangentSpace[jax.Array],\n    dt: float,\n    metric: MetricFn,\n    integral_approximator: IntegralApproximationFn = mean_integration,\n) -&gt; jax.Array:\n    r\"\"\"Compute length of the geodesic.\n\n    The length of a geodesic is defined as\n\n    $$\n    L(\\gamma, \\dot{\\gamma}) = \\int_0^1 \\sqrt{ g_{\\gamma} (\\dot{\\gamma}, \\dot{\\gamma}) } dt.\n    $$\n\n    We note that this is not necessarily equivalent to the geodesic distance between two points.\n\n    Parameters:\n        geodesic: point on the geodesic\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        length of the geodesic\n    \"\"\"\n\n    quantity_fn = jtu.Partial(_compute_discretised_length, metric=metric)\n    return _integrate_curve_quantity(quantity_fn, geodesic, dt, integral_approximator)\n</code></pre>"},{"location":"manifold/geodesic/#riemax.manifold.geodesic.compute_geodesic_energy","title":"<code>riemax.manifold.geodesic.compute_geodesic_energy(geodesic: TangentSpace[jax.Array], dt: float, metric: MetricFn, integral_approximator: IntegralApproximationFn = mean_integration) -&gt; jax.Array</code>","text":"<p>Compute energy of the geodesic.</p> <p>The energy of a geodesic is defined as</p> \\[ E(\\gamma, \\dot{\\gamma}) = \\int_0^1 g_{\\gamma} (\\dot{\\gamma}, \\dot{\\gamma}) dt. \\] <p>Parameters:</p> Name Type Description Default <code>geodesic</code> <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>point on the geodesic</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>energy of the geodesic</p> Source code in <code>src/riemax/manifold/geodesic.py</code> <pre><code>def compute_geodesic_energy(\n    geodesic: TangentSpace[jax.Array],\n    dt: float,\n    metric: MetricFn,\n    integral_approximator: IntegralApproximationFn = mean_integration,\n) -&gt; jax.Array:\n    r\"\"\"Compute energy of the geodesic.\n\n    The energy of a geodesic is defined as\n\n    $$\n    E(\\gamma, \\dot{\\gamma}) = \\int_0^1 g_{\\gamma} (\\dot{\\gamma}, \\dot{\\gamma}) dt.\n    $$\n\n    Parameters:\n        geodesic: point on the geodesic\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        energy of the geodesic\n    \"\"\"\n\n    quantity_fn = jtu.Partial(_compute_discretised_energy, metric=metric)\n    return _integrate_curve_quantity(quantity_fn, geodesic, dt, integral_approximator)\n</code></pre>"},{"location":"manifold/geodesic/#riemax.manifold.geodesic.minimising_geodesic","title":"<code>riemax.manifold.geodesic.minimising_geodesic(p: M[jax.Array], q: M[jax.Array], metric: MetricFn, optimiser: optax.GradientTransformation, num_nodes: int = 20, n_collocation: int = 100, iterations: int = 100, tol: float = 0.0001) -&gt; tuple[TangentSpace[jax.Array], bool]</code>","text":"<p>Obtain energy-minimising geodesics between two points.</p> <p>This implementation models the geodesic as a cubic spline, constrained at the two end-points. An optimisation problem is solved, obtaining parameters of the cubic spline which minimise the energy of the resulting geodesic; ideally, obtaining the length-minimising geodesic between the two points.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>riemax.manifold.types.M[jax.Array]</code> <p>first end-point of the geodesic</p> required <code>q</code> <code>riemax.manifold.types.M[jax.Array]</code> <p>second end-point of the geodesic</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <code>optimiser</code> <code>optax.GradientTransformation</code> <p>optimiser to use for the optimisation procedure</p> required <code>num_nodes</code> <code>int</code> <p>number of nodes to parameterise the cubic spline by</p> <code>20</code> <code>n_collocation</code> <code>int</code> <p>number of points to evaluate energy at</p> <code>100</code> <code>iterations</code> <code>int</code> <p>number of iterations to optimise for</p> <code>100</code> <code>tol</code> <code>float</code> <p>tolerance for gradients of updates</p> <code>0.0001</code> <p>Returns:</p> Type Description <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>optimised geodesic, connecting the two points</p> <code>bool</code> <p>whether the optimisation procedure converged</p> Source code in <code>src/riemax/manifold/geodesic.py</code> <pre><code>def minimising_geodesic(\n    p: M[jax.Array],\n    q: M[jax.Array],\n    metric: MetricFn,\n    optimiser: optax.GradientTransformation,\n    num_nodes: int = 20,\n    n_collocation: int = 100,\n    iterations: int = 100,\n    tol: float = 1e-4,\n) -&gt; tuple[TangentSpace[jax.Array], bool]:\n    \"\"\"Obtain energy-minimising geodesics between two points.\n\n    This implementation models the geodesic as a cubic spline, constrained at the two end-points. An optimisation\n    problem is solved, obtaining parameters of the cubic spline which minimise the energy of the resulting geodesic;\n    ideally, obtaining the length-minimising geodesic between the two points.\n\n    Parameters:\n        p: first end-point of the geodesic\n        q: second end-point of the geodesic\n        metric: function defining the metric tensor on the manifold\n        optimiser: optimiser to use for the optimisation procedure\n        num_nodes: number of nodes to parameterise the cubic spline by\n        n_collocation: number of points to evaluate energy at\n        iterations: number of iterations to optimise for\n        tol: tolerance for gradients of updates\n\n    Returns:\n        optimised geodesic, connecting the two points\n        whether the optimisation procedure converged\n    \"\"\"\n\n    curve = CubicSpline.from_nodes(p, q, num_nodes)\n    tt = jnp.linspace(0, 1, n_collocation, endpoint=True)\n\n    @jax.jit\n    def loss_fn(params: jax.Array) -&gt; jax.Array:\n        p_fn = jtu.Partial(_compute_discretised_energy, metric=metric)\n        discrete_fn_eval = jax.vmap(p_fn)(curve.evaluate(tt, params))\n\n        return jnp.mean(discrete_fn_eval)\n\n    @jax.jit\n    def update(\n        params: jax.Array, opt_state: optax.OptState\n    ) -&gt; tuple[jax.Array, tuple[jax.Array, optax.OptState, jax.Array]]:\n        loss, grads = jax.value_and_grad(loss_fn)(params)\n        max_grad = jnp.max(grads)\n\n        updates, opt_state = optimiser.update(grads, opt_state, params=params)\n        params = tp.cast(jax.Array, optax.apply_updates(params, updates))\n\n        return loss, (params, opt_state, max_grad)\n\n    params = curve.init_params()\n    opt_state = optimiser.init(params)\n\n    max_grad = jnp.inf\n    for _ in range(iterations):\n        loss, (params, opt_state, max_grad) = update(params, opt_state)\n\n        if max_grad &lt; tol:\n            break\n\n    geodesic = curve.evaluate(tt, params)\n\n    return geodesic, max_grad &lt; tol\n</code></pre>"},{"location":"manifold/geodesic/#riemax.manifold.geodesic.scipy_bvp_geodesic","title":"<code>riemax.manifold.geodesic.scipy_bvp_geodesic(p: jax.Array, q: jax.Array, metric: MetricFn, n_collocation: int = 100, explicit_jacobian: bool = False, tol: float = 0.0001) -&gt; tuple[TangentSpace[jax.Array], bool]</code>","text":"<p>Obtain geodesic connecting two points using scipy.integrate.solve_bvp</p> <p>This method mirrors <code>minimising_geodesic</code> as scipy uses a similar scheme to solve boundary value problems. The scipy implementation does not consider fixed end-points though, and a separate set of boundary conditions must be optimised for. While the scipy implementation is more complete in terms of implementation, external calls are slower and cannot be jitted. The necessity for minimising a boundary condition residual is also a consideration.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>jax.Array</code> <p>first end-point of the geodesic</p> required <code>q</code> <code>jax.Array</code> <p>second end-point of the geodesic</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <code>n_collocation</code> <code>int</code> <p>number of points to evaluate energy at</p> <code>100</code> <code>explicit_jacobian</code> <code>bool</code> <p>whether to use jacobian computed by jax</p> <code>False</code> <code>tol</code> <code>float</code> <p>tolerance for gradients of updates</p> <code>0.0001</code> <p>Returns:</p> Type Description <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>optimised geodesic, connecting the two points</p> <code>bool</code> <p>whether the optimisation procedure converged</p> Source code in <code>src/riemax/manifold/geodesic.py</code> <pre><code>def scipy_bvp_geodesic(\n    p: jax.Array,\n    q: jax.Array,\n    metric: MetricFn,\n    n_collocation: int = 100,\n    explicit_jacobian: bool = False,\n    tol: float = 1e-4,\n) -&gt; tuple[TangentSpace[jax.Array], bool]:\n    \"\"\"Obtain geodesic connecting two points using scipy.integrate.solve_bvp\n\n    This method mirrors `minimising_geodesic` as scipy uses a similar scheme to solve boundary value problems. The scipy\n    implementation does not consider fixed end-points though, and a separate set of boundary conditions must be\n    optimised for. While the scipy implementation is more complete in terms of implementation, external calls are slower\n    and cannot be jitted. The necessity for minimising a boundary condition residual is also a consideration.\n\n    Parameters:\n        p: first end-point of the geodesic\n        q: second end-point of the geodesic\n        metric: function defining the metric tensor on the manifold\n        n_collocation: number of points to evaluate energy at\n        explicit_jacobian: whether to use jacobian computed by jax\n        tol: tolerance for gradients of updates\n\n    Returns:\n        optimised geodesic, connecting the two points\n        whether the optimisation procedure converged\n    \"\"\"\n\n    ndim = p.size\n    dynamics = jtu.Partial(geodesic_dynamics, metric=metric)\n\n    def numpy_wrapped(fn):\n        @ft.wraps(fn)\n        def inner(*args: np.ndarray):\n            return tuple(map(np.asarray, fn(*map(jnp.asarray, args))))\n\n        return inner\n\n    def t_last(fn):\n        @ft.wraps(fn)\n        def inner(*args):\n            return einops.rearrange(fn(*args), 't ... -&gt; ... t')\n\n        return inner\n\n    def _fn_ode(_: jax.Array, x: jax.Array):\n        geodesic_state = TangentSpace(point=x[:ndim, :].T, vector=x[ndim:, :].T)\n        geodesic_update = jax.vmap(dynamics)(geodesic_state)\n\n        geodesic_update = jnp.concatenate(jtu.tree_leaves(geodesic_update))\n\n        return geodesic_update\n\n    fn_ode = numpy_wrapped(t_last(jax.vmap(_fn_ode, in_axes=(None, 1))))\n\n    fn_jacobian = None\n    if explicit_jacobian:\n        fn_jacobian = numpy_wrapped(t_last(jax.vmap(jax.jacobian(_fn_ode, argnums=1), in_axes=(None, 1))))\n\n    @numpy_wrapped\n    def fn_bc(ya, yb):\n        ra = ya[:ndim] - p\n        rb = yb[:ndim] - q\n\n        return jnp.concatenate((ra, rb))\n\n    x_init = np.linspace(0.0, 1.0, n_collocation, endpoint=True)\n\n    gamma_init = np.einsum('i, j -&gt; ij', p, (1.0 - x_init)) + np.einsum('i, j -&gt; ij', q, x_init)\n    gamma_dot_init = einops.repeat(q - p, 'i -&gt; i t', t=n_collocation)\n\n    y_init = np.concatenate((gamma_init, gamma_dot_init), axis=0)\n\n    bvp_result = solve_bvp(fn_ode, fn_bc, x_init, y_init, fun_jac=fn_jacobian, tol=tol)\n    geodesic = TangentSpace(point=bvp_result[:ndim, :].T, vector=bvp_result[ndim:, :].T)\n\n    return geodesic, bvp_result.success\n</code></pre>"},{"location":"manifold/geometry/","title":"Geometry","text":"<p>Riemax is capable of computing a number of intrinsic quantities on the manifold. Each of these rely on having a continuous definition of an induced metric, which is then exploited through JAX's automatic-differentiation to compute quantities of interest on the manifold.</p> <p>Please see the following references for an introduction.<sup>1</sup><sup>2</sup><sup>3</sup><sup>4</sup></p> <ol> <li> <p>Carmo, Manfredo Perdig\u00e3o do. Differential Geometry of Curves &amp; Surfaces. 2018.\u00a0\u21a9</p> </li> <li> <p>Carmo, Manfredo Perdig\u00e3o do. Riemannian Geometry. 2013.\u00a0\u21a9</p> </li> <li> <p>Lee, John M. Introduction to Riemannian Manifolds. 2018.\u00a0\u21a9</p> </li> <li> <p>Lee, John M. Introduction to Smooth Manifolds. 2012.\u00a0\u21a9</p> </li> </ol>"},{"location":"manifold/geometry/#src.riemax.geometry","title":"<code>src.riemax.geometry</code>","text":""},{"location":"manifold/geometry/#src.riemax.geometry.pullback","title":"<code>src.riemax.geometry.pullback(f: tp.Callable[P, T], fn_transformation: tp.Callable[[jax.Array], jax.Array]) -&gt; tp.Callable[P, T]</code>","text":"<p>Define the pullback of a function by a transformation.</p> <p>Let \\(\\iota: M \\hookrightarrow N\\) be a smooth immersion, and suppose \\(f: N \\rightarrow S\\) is a smooth function on N. Then we define the pullback of \\(f\\) by \\(\\iota\\) as the smooth function \\(\\iota^\\ast f: M \\rightarrow S\\), or:</p> \\[ (\\iota^\\ast f)(x) = f(\\iota(x)) \\] <p>Example:</p> <p>One notable example is computing the Euclidean distance \\(d_E(p, q) = \\lVert p - q \\rVert_2\\) between two points on the manifold, we can use the pullback to do this.</p> <p>In code, we may write something like</p> <pre><code># ...\n\ndef euclidean_distance(p: jax.Array, q: jax.Array) -&gt; jax.Array:\n    return jnp.sum(jnp.square(p - q))\n\n# pullback_distance: Callable[[M[jax.Array]], Rn[jax.Array]]\npullback_distance = riemax.geometry.pullback(euclidean_distance, fn_transformation)\n</code></pre> <ol> <li> <p>Carmo, Manfredo Perdig\u00e3o do. Differential Geometry of Curves &amp; Surfaces. 2018.\u00a0\u21a9</p> </li> <li> <p>Lee, John M. Introduction to Smooth Manifolds. 2012.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>typing.Callable[P, T]</code> <p>function, \\(f: N \\rightarrow S\\), to pullback.</p> required <code>fn_transformation</code> <code>typing.Callable[[jax.Array], jax.Array]</code> <p>function defining smooth immersion, \\(\\iota: M \\hookrightarrow N\\)</p> required <p>Returns:</p> Name Type Description <code>f_pullback</code> <code>typing.Callable[P, T]</code> <p>pullback of f by fn_transformation, \\(\\iota^\\ast f: M \\rightarrow S\\)</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>def pullback[**P, T](f: tp.Callable[P, T], fn_transformation: tp.Callable[[jax.Array], jax.Array]) -&gt; tp.Callable[P, T]:\n    r\"\"\"Define the pullback of a function by a transformation.\n\n    Let $\\iota: M \\hookrightarrow N$ be a smooth immersion, and suppose $f: N \\rightarrow S$ is a smooth function on N.\n    Then we define the **pullback** of $f$ by $\\iota$ as the smooth function $\\iota^\\ast f: M \\rightarrow S$, or:\n\n    $$\n    (\\iota^\\ast f)(x) = f(\\iota(x))\n    $$\n\n    **Example:**\n\n    One notable example is computing the Euclidean distance $d_E(p, q) = \\lVert p - q \\rVert_2$ between two points on\n    the manifold, we can use the pullback to do this.\n\n    In code, we may write something like\n\n    ```python\n    # ...\n\n    def euclidean_distance(p: jax.Array, q: jax.Array) -&gt; jax.Array:\n        return jnp.sum(jnp.square(p - q))\n\n    # pullback_distance: Callable[[M[jax.Array]], Rn[jax.Array]]\n    pullback_distance = riemax.geometry.pullback(euclidean_distance, fn_transformation)\n    ```\n\n    [^1]: Carmo, Manfredo Perdig\u00e3o do. Differential Geometry of Curves &amp; Surfaces. 2018.\n    [^2]: Lee, John M. Introduction to Smooth Manifolds. 2012.\n\n    Parameters:\n        f: function, $f: N \\rightarrow S$, to pullback.\n        fn_transformation: function defining smooth immersion, $\\iota: M \\hookrightarrow N$\n\n    Returns:\n        f_pullback: pullback of f by fn_transformation, $\\iota^\\ast f: M \\rightarrow S$\n    \"\"\"\n\n    def f_pullback(*args: P.args, **kwargs: P.kwargs) -&gt; T:\n        args = jtu.tree_map(fn_transformation, args)\n        kwargs = jtu.tree_map(fn_transformation, kwargs)\n\n        return f(*args, **kwargs)\n\n    return f_pullback\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.metric_tensor","title":"<code>src.riemax.geometry.metric_tensor(x: M[jax.Array], fn_transformation: tp.Callable[[M[jax.Array]], jax.Array]) -&gt; jax.Array</code>","text":"<p>Computes the covariant metric tensor at a point \\(p \\in M\\)</p> <p>Given a smooth immersion \\(\\iota: M \\hookrightarrow N\\), we can define the induced metric:</p> \\[ g_{ij} = \\frac{\\partial \\iota}{\\partial x^i}\\frac{\\partial \\iota}{\\partial x^j} \\] <p>For the given point \\(p \\in M\\), the induced metric \\(g\\) allows us to operate locally on the tangent space \\(T_p M\\). Precisely, the induced metric is a symmetric bilinear form \\(g: T_p M \\times T_p M \\rightarrow \\mathbb{R}\\). This allows us to compute distances and angles in the tangent space, and is used to compute most intrinsic quantities on the manifold.<sup>1</sup><sup>2</sup></p> <ol> <li> <p>Carmo, Manfredo Perdig\u00e3o do. Riemannian Geometry. 2013.\u00a0\u21a9</p> </li> <li> <p>Lee, John M. Introduction to Riemannian Manifolds. 2018.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate the metric tensor</p> required <code>fn_transformation</code> <code>typing.Callable[[src.riemax.manifold.types.M[jax.Array]], jax.Array]</code> <p>function defining smooth immersion, \\(\\iota: M \\hookrightarrow N\\)</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>covariant metric tensor, \\(g_{ij}(p)\\)</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>def metric_tensor(x: M[jax.Array], fn_transformation: tp.Callable[[M[jax.Array]], jax.Array]) -&gt; jax.Array:\n    r\"\"\"Computes the covariant metric tensor at a point $p \\in M$\n\n    Given a smooth immersion $\\iota: M \\hookrightarrow N$, we can define the induced metric:\n\n    $$\n    g_{ij} = \\frac{\\partial \\iota}{\\partial x^i}\\frac{\\partial \\iota}{\\partial x^j}\n    $$\n\n    For the given point $p \\in M$, the induced metric $g$ allows us to operate locally on the tangent space $T_p M$.\n    Precisely, the induced metric is a symmetric bilinear form $g: T_p M \\times T_p M \\rightarrow \\mathbb{R}$. This\n    allows us to compute distances and angles in the tangent space, and is used to compute most intrinsic quantities\n    on the manifold.[^1][^2]\n\n    [^1]: Carmo, Manfredo Perdig\u00e3o do. Riemannian Geometry. 2013.\n    [^2]: Lee, John M. Introduction to Riemannian Manifolds. 2018.\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate the metric tensor\n        fn_transformation: function defining smooth immersion, $\\iota: M \\hookrightarrow N$\n\n    Returns:\n        covariant metric tensor, $g_{ij}(p)$\n    \"\"\"\n\n    fn_jacobian = jax.jacobian(fn_transformation)(x)\n    return jnp.einsum('ki, kj -&gt; ij', fn_jacobian, fn_jacobian)\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.inner_product","title":"<code>src.riemax.geometry.inner_product(x: M[jax.Array], v: TpM[jax.Array], w: TpM[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Compute inner product on the tanget plane, \\(g_p (v, w)\\).</p> <p>The inner product is essential for computing the magnitude of vectors on the tangent space and can be used in computing the angles between two tangent vectors.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate the inner product</p> required <code>v</code> <code>src.riemax.manifold.types.TpM[jax.Array]</code> <p>first vector on the tangent space, \\(v \\in T_p M\\)</p> required <code>w</code> <code>src.riemax.manifold.types.TpM[jax.Array]</code> <p>second vector on the tangent space, \\(w \\in T_p M\\)</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>inner product between \\(v, w \\in T_p M\\) computed at \\(p \\in M\\)</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef inner_product(x: M[jax.Array], v: TpM[jax.Array], w: TpM[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Compute inner product on the tanget plane, $g_p (v, w)$.\n\n    The inner product is essential for computing the magnitude of vectors on the tangent space and can be used in\n    computing the angles between two tangent vectors.\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate the inner product\n        v: first vector on the tangent space, $v \\in T_p M$\n        w: second vector on the tangent space, $w \\in T_p M$\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        inner product between $v, w \\in T_p M$ computed at $p \\in M$\n    \"\"\"\n\n    return jnp.einsum('ij, i, j -&gt; ', metric(x), v, w)\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.magnitude","title":"<code>src.riemax.geometry.magnitude(x: M[jax.Array], v: TpM[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Compute length of vector on the tangent space, \\(\\lVert v \\rVert\\)</p> <p>The metric \\(g\\) provides the ability to compute the inner product on the tangent space. Using the standard definition of the inner product, we can compute the length of a vector as</p> \\[ \\lVert v \\rVert = \\langle v, v \\rangle^{0.5}_g = \\sqrt{g_p(v, v)} \\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which the tangent vector is defined</p> required <code>v</code> <code>src.riemax.manifold.types.TpM[jax.Array]</code> <p>tangent vector \\(v\\) to compute the magnitude of</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>length of the tangent vector \\(v\\) at the point \\(p \\in M\\)</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef magnitude(x: M[jax.Array], v: TpM[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Compute length of vector on the tangent space, $\\lVert v \\rVert$\n\n    The metric $g$ provides the ability to compute the inner product on the tangent space. Using the standard definition\n    of the inner product, we can compute the length of a vector as\n\n    $$\n    \\lVert v \\rVert = \\langle v, v \\rangle^{0.5}_g = \\sqrt{g_p(v, v)}\n    $$\n\n    Parameters:\n        x: position $p \\in M$ at which the tangent vector is defined\n        v: tangent vector $v$ to compute the magnitude of\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        length of the tangent vector $v$ at the point $p \\in M$\n    \"\"\"\n\n    return jnp.sqrt(inner_product(x, v, v, metric))\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.contravariant_metric_tensor","title":"<code>src.riemax.geometry.contravariant_metric_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Computes inverse of the metric tensor.</p> <p>We observe that the identity \\(g_{ij} g^{ij} = I\\) holds. This function allows us to compute the inverse of the covariant metric tensor, an important tool allowing us to raise indices</p> \\[ v^i = g^{ij} v_j = (v_i)^\\sharp \\] <p>Computing the Inverse:</p> <p>At the moment, we explicitly take the inverse of the covariant metric tensor by using <code>jnp.linalg.inv</code>. For large systems, we may want to solve for this instead.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate the inverse of the metric tensor</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>contravariant metric tensor.</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef contravariant_metric_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Computes inverse of the metric tensor.\n\n    We observe that the identity $g_{ij} g^{ij} = I$ holds. This function allows us to compute the inverse of the\n    covariant metric tensor, an important tool allowing us to raise indices\n\n    $$\n    v^i = g^{ij} v_j = (v_i)^\\sharp\n    $$\n\n    !!! warning \"Computing the Inverse:\"\n\n        At the moment, we explicitly take the inverse of the covariant metric tensor by using `jnp.linalg.inv`. For\n        large systems, we may want to solve for this instead.\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate the inverse of the metric tensor\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        contravariant metric tensor.\n    \"\"\"\n\n    return jnp.linalg.inv(metric(x))\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.fk_christoffel","title":"<code>src.riemax.geometry.fk_christoffel(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Christoffel symbols of the first kind \\(\\Gamma_{kij} = \\left[ ij, k \\right]\\).</p> <p>These Christoffel symbols are components of the affine connection, defined as</p> \\[ \\Gamma_{kij} = 0.5 \\left( \\partial g_{ki, j} + \\partial g_{kj, i} - \\partial g_{ij, k} \\right). \\] <p>These allow us to compute the geodesic equation, measures of curvature, and more.<sup>1</sup><sup>2</sup></p> <ol> <li> <p>Carmo, Manfredo Perdig\u00e3o do. Differential Geometry of Curves &amp; Surfaces. 2018.\u00a0\u21a9</p> </li> <li> <p>Lee, John M. Introduction to Smooth Manifolds. 2012.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate Christoffel symbols</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>christoffel symbols of the first kind.</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef fk_christoffel(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Christoffel symbols of the first kind $\\Gamma_{kij} = \\left[ ij, k \\right]$.\n\n    These Christoffel symbols are components of the affine connection, defined as\n\n    $$\n    \\Gamma_{kij} = 0.5 \\left( \\partial g_{ki, j} + \\partial g_{kj, i} - \\partial g_{ij, k} \\right).\n    $$\n\n    These allow us to compute the geodesic equation, measures of curvature, and more.[^1][^2]\n\n    [^1]: Carmo, Manfredo Perdig\u00e3o do. Differential Geometry of Curves &amp; Surfaces. 2018.\n    [^2]: Lee, John M. Introduction to Smooth Manifolds. 2012.\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate Christoffel symbols\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        christoffel symbols of the first kind.\n    \"\"\"\n\n    dgdx = jax.jacobian(metric)(x)\n\n    def get_value(k, i, j) -&gt; jax.Array:\n        return 0.5 * (dgdx[k, i, j] + dgdx[k, j, i] - dgdx[i, j, k])\n\n    return jnp.vectorize(get_value)(*jnp.indices(dgdx.shape))\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.sk_christoffel","title":"<code>src.riemax.geometry.sk_christoffel(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Christoffel symbols of the second kind: \\(\\Gamma^k_{\\phantom{k}ij} = \\left\\{ ij, k \\right\\}\\)</p> <p>The Christoffel symbols of the second-kind are simply index-raised versions of the Christoffel symbols of the first kind. We simply use the inverse of the metric tensor to raise the index,</p> \\[ \\Gamma^k_{\\phantom{k}ij} = g^{km} \\Gamma_{mij}. \\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate Christoffel symbols of the second kind</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>Christoffel symbol of the second kind.</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef sk_christoffel(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Christoffel symbols of the second kind: $\\Gamma^k_{\\phantom{k}ij} = \\left\\{ ij, k \\right\\}$\n\n    The Christoffel symbols of the second-kind are simply index-raised versions of the Christoffel symbols of the first\n    kind. We simply use the inverse of the metric tensor to raise the index,\n\n    $$\n    \\Gamma^k_{\\phantom{k}ij} = g^{km} \\Gamma_{mij}.\n    $$\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate Christoffel symbols of the second kind\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        Christoffel symbol of the second kind.\n    \"\"\"\n\n    fk_christ = fk_christoffel(x, metric)\n    contravariant_g_ij = contravariant_metric_tensor(x, metric)\n\n    return jnp.einsum('kn, nij -&gt; kij', contravariant_g_ij, fk_christ)\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.sk_riemann_tensor","title":"<code>src.riemax.geometry.sk_riemann_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Compute Riemann curvature tensor of the second kind, \\(R^i_{\\phantom{i}jkl}\\)</p> <p>The Riemann tensor provides a notion of curvature on the manifold. It is defined in terms of covariant derivatives</p> \\[ R(X, Y) = \\left[ \\nabla_X, \\nabla_Y \\right] - \\nabla_{\\left[X, Y \\right]} \\] <p>This is expressible entirely in terms of the Christoffel symbols, which are used in the computation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate the Riemann curvature tensor.</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>Riemann curvature tensor of the second kind.</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef sk_riemann_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Compute Riemann curvature tensor of the second kind, $R^i_{\\phantom{i}jkl}$\n\n    The Riemann tensor provides a notion of curvature on the manifold. It is defined in terms of covariant derivatives\n\n    $$\n    R(X, Y) = \\left[ \\nabla_X, \\nabla_Y \\right] - \\nabla_{\\left[X, Y \\right]}\n    $$\n\n    This is expressible entirely in terms of the Christoffel symbols, which are used in the computation.\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate the Riemann curvature tensor.\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        Riemann curvature tensor of the second kind.\n    \"\"\"\n\n    # create partial to allow us to compute Jacobian easily\n    fn_sk_christoffel = jtu.Partial(sk_christoffel, metric=metric)\n    p_fn_sk_christoffel = jax.jacfwd(fn_sk_christoffel)\n\n    # christoffel symbols [ij, k]\n    g_ijk = fn_sk_christoffel(x)\n\n    # compute the second term, [ij, k]_{,m}\n    g_ijk_m = p_fn_sk_christoffel(x)\n\n    # compute first term via transposition of the first term\n    g_ijm_k = einops.rearrange(g_ijk_m, 'i j k m -&gt; i j m k')\n\n    # compute third and fourth terms\n    g_irk_g_rjm = jnp.einsum('irk, rjm -&gt; ijkm', g_ijk, g_ijk)\n    g_irm_g_rjk = jnp.einsum('irm, rjk -&gt; ijkm', g_ijk, g_ijk)\n\n    return g_ijm_k - g_ijk_m + g_irk_g_rjm - g_irm_g_rjk\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.fk_riemann_tensor","title":"<code>src.riemax.geometry.fk_riemann_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Compute Riemann tensor of the first kind, \\(R_{ijkl}\\)</p> <p>The Riemann tensor of the first-kind is the index-lowered variant of the Riemann tensor of the second-kind. We simply apply an index contraction with the metric tensor to achieve this.</p> <p>Note</p> <p>A more efficient implementation would involve computing this directly by using Christoffel symbols of the first kind. The approach implemented here is a little easier to understand. It will not matter once it has been compiled down.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate the Riemann curvature tensor</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>Riemann tensor of the first kind at the point \\(p \\in M\\)</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef fk_riemann_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Compute Riemann tensor of the first kind, $R_{ijkl}$\n\n    The Riemann tensor of the first-kind is the index-lowered variant of the Riemann tensor of the second-kind. We\n    simply apply an index contraction with the metric tensor to achieve this.\n\n    !!! note\n        A more efficient implementation would involve computing this directly by using Christoffel symbols of the\n        first kind. The approach implemented here is a little easier to understand. It will not matter once it has\n        been compiled down.\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate the Riemann curvature tensor\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        Riemann tensor of the first kind at the point $p \\in M$\n    \"\"\"\n\n    g_ir = metric(x)\n    r_rjkm = sk_riemann_tensor(x, metric)\n\n    return jnp.einsum('ir, rjkm -&gt; ijkm', g_ir, r_rjkm)\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.ricci_tensor","title":"<code>src.riemax.geometry.ricci_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Compute the Ricci tensor, \\(R_{ij}\\)</p> <p>The Ricci tensor \\(R_{ij}\\) is a tensor contraction of the Riemann curvature tensor \\(R^i_{\\phantom{i}jkl}\\) over the first and third indices, precisely</p> \\[ R_{ij} = R^k_{\\phantom{k}ikj} \\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate the Riemann tensor</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>Ricci tensor at the point \\(p \\in M\\)</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef ricci_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Compute the Ricci tensor, $R_{ij}$\n\n    The Ricci tensor $R_{ij}$ is a tensor contraction of the Riemann curvature tensor $R^i_{\\phantom{i}jkl}$ over the\n    first and third indices, precisely\n\n    $$\n    R_{ij} = R^k_{\\phantom{k}ikj}\n    $$\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate the Riemann tensor\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        Ricci tensor at the point $p \\in M$\n    \"\"\"\n\n    r_kikj = sk_riemann_tensor(x, metric)\n    return jnp.einsum('kikj -&gt; ij', r_kikj)\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.ricci_scalar","title":"<code>src.riemax.geometry.ricci_scalar(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Compute the Ricci scalar, \\(R\\).</p> <p>The Ricci scalar \\(R\\) yields a single real number which quantifies the curvature on the manifold. It is obtained through taking the geometric trace of the Ricci tensor, \\(R_{ij}\\):</p> \\[ R = g^{ij} R_{ij} \\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate the Riemann tensor</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>Ricci scalar at the point \\(p \\in M\\)</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef ricci_scalar(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Compute the Ricci scalar, $R$.\n\n    The Ricci scalar $R$ yields a single real number which quantifies the curvature on the manifold. It is obtained\n    through taking the geometric trace of the Ricci tensor, $R_{ij}$:\n\n    $$\n    R = g^{ij} R_{ij}\n    $$\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate the Riemann tensor\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        Ricci scalar at the point $p \\in M$\n    \"\"\"\n\n    contra_g_ij = contravariant_metric_tensor(x, metric)\n    r_ij = ricci_tensor(x, metric)\n\n    return jnp.einsum('ij, ij -&gt; ', contra_g_ij, r_ij)\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.einstein_tensor","title":"<code>src.riemax.geometry.einstein_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Compute the Einstein tensor, \\(G_{ij}\\)</p> <p>The Einstein tensor, also known as the trace-reversed Ricci tensor is defined as</p> \\[ G_{ij} = R_{ij} - \\frac{1}{2} g_{ij} R, \\] <p>wjere \\(R_{ij}\\) is the Ricci tensor, and \\(R\\) is the Ricci scalar.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate the Einstein tensor</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>Einstein tensor at the point \\(p \\in M\\)</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef einstein_tensor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Compute the Einstein tensor, $G_{ij}$\n\n    The Einstein tensor, also known as the trace-reversed Ricci tensor is defined as\n\n    $$\n    G_{ij} = R_{ij} - \\frac{1}{2} g_{ij} R,\n    $$\n\n    wjere $R_{ij}$ is the Ricci tensor, and $R$ is the Ricci scalar.\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate the Einstein tensor\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        Einstein tensor at the point $p \\in M$\n    \"\"\"\n\n    g_ij = metric(x)\n\n    ricci_t = ricci_tensor(x, metric)\n\n    # note: we avoid calls to `contravariant_metric_tensor, ricci_scalar`\n    #       to avoid unnecessary computation of the metric and ricci tensor.\n    ricci_s = jnp.einsum('ij, ij -&gt; ', jnp.linalg.inv(g_ij), ricci_t)  # type: ignore\n\n    return ricci_t - 0.5 * g_ij * ricci_s\n</code></pre>"},{"location":"manifold/geometry/#src.riemax.geometry.magnification_factor","title":"<code>src.riemax.geometry.magnification_factor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Compute the magnification factor.</p> <p>The magnification factor provides a measure of the local distortion of the distance. It is defined as</p> \\[ MF = \\sqrt{\\lvert g \\rvert} \\] <p>Parameters:</p> Name Type Description Default <code>x</code> <code>src.riemax.manifold.types.M[jax.Array]</code> <p>position \\(p \\in M\\) at which to evaluate the Riemann tensor</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>magnification factor at the point \\(p \\in M\\).</p> Source code in <code>src/riemax/manifold/geometry.py</code> <pre><code>@manifold_marker.mark(jittable=True)\ndef magnification_factor(x: M[jax.Array], metric: MetricFn) -&gt; jax.Array:\n    r\"\"\"Compute the magnification factor.\n\n    The magnification factor provides a measure of the local distortion of the distance. It is defined as\n\n    $$\n    MF = \\sqrt{\\lvert g \\rvert}\n    $$\n\n    Parameters:\n        x: position $p \\in M$ at which to evaluate the Riemann tensor\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        magnification factor at the point $p \\in M$.\n    \"\"\"\n\n    return jnp.sqrt(jnp.linalg.det(metric(x)))\n</code></pre>"},{"location":"manifold/maps/","title":"maps","text":"<p>The <code>riemax.manifold.maps</code> module allows the user to define the exponential and log maps on a manifold. These are defined using the geodesic dynamics, defined in <code>riemax.manifold.geodesic</code>.</p>"},{"location":"manifold/maps/#types","title":"Types:","text":"<pre><code>type ExponentialMap = tp.Callable[[TangentSpace[jax.Array]], tuple[M[jax.Array], TangentSpace[jax.Array]]]\ntype LogMap[*Ts] = tp.Callable[[M[jax.Array], M[jax.Array], *Ts], tuple[TangentSpace[jax.Array], bool]]\n</code></pre>"},{"location":"manifold/maps/#exponential-map","title":"Exponential Map","text":"<p>Suppose we have a continuous, differentiable manifold, \\(M\\). Given a point \\(p \\in M\\), and tangent vector \\(v \\in T_p M\\), there exists a unique geodesic \\(\\gamma_v : [0, 1] \\rightarrow M\\) satisfying \\(\\gamma_v(0) = p\\), \\(\\dot{\\gamma}_v(0) = v\\). The exponential map is defined by \\(\\exp_p(v) = \\gamma_v(1)\\), or \\(\\exp_p : T_p M \\rightarrow M\\).</p>"},{"location":"manifold/maps/#log-map","title":"Log Map","text":"<p>Given two points \\(p, q \\in M\\), the \\(\\log\\) map provides the tangent-vector which, upon application of the exponential map, transports one point to the other.  The log map is the natural inverse of the exponential map, defined as \\(\\log_p(q) = v\\) such that \\(\\exp_p(\\log_p(q)) = q\\). This mapping is not unique as there may be many tangent-vectors which connect the two points \\(p, q\\).</p>"},{"location":"manifold/maps/#shooting-solver","title":"Shooting Solver","text":"<p>Ordinarily, we would consider computing the \\(\\log\\) map a two-point boundary value problem. We can approach this using a shooting method, posing the problem: find \\(v \\in T_p M\\) such that \\(\\exp_p (v) = q\\). We define the residual</p> \\[ r(v) = \\exp_p(v) - q, \\] <p>and use a root-finding technique, such as Newton-Raphson, to obtain a solution. While this remains a principled approach, it is somewhat reliant on having a good initial guess for the solution.</p>"},{"location":"manifold/maps/#riemax.manifold.maps","title":"<code>riemax.manifold.maps</code>","text":""},{"location":"manifold/maps/#riemax.manifold.maps.exponential_map_factory","title":"<code>riemax.manifold.maps.exponential_map_factory(integrator: Integrator[TangentSpace[jax.Array]], dt: float, metric: MetricFn, n_steps: int | None = None) -&gt; ExponentialMap</code>","text":"<p>Produce an exponential map, \\(\\exp: TM \\rightarrow M\\).</p> <p>Example:</p> <pre><code># ...\n\nexp_map = exponential_map_factory(riemax.numerical.integrators.odeint, dt=1e-3, metric=fn_metric)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>riemax.numerical.integrators.Integrator[riemax.manifold.types.TangentSpace[jax.Array]]</code> <p>choice of integrator used to propgate dynamics</p> required <code>dt</code> <code>float</code> <p>time-step for the integration</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <code>n_steps</code> <code>int | None</code> <p>number of steps to integrate for</p> <code>None</code> <p>Returns:</p> Name Type Description <code>exp_map</code> <code>ExponentialMap</code> <p>function for computing exponential map</p> Source code in <code>src/riemax/manifold/maps.py</code> <pre><code>def exponential_map_factory(\n    integrator: Integrator[TangentSpace[jax.Array]], dt: float, metric: MetricFn, n_steps: int | None = None\n) -&gt; ExponentialMap:\n    r\"\"\"Produce an exponential map, $\\exp: TM \\rightarrow M$.\n\n    !!! note \"Example:\"\n\n        ```python\n        # ...\n\n        exp_map = exponential_map_factory(riemax.numerical.integrators.odeint, dt=1e-3, metric=fn_metric)\n        ```\n\n    Parameters:\n        integrator: choice of integrator used to propgate dynamics\n        dt: time-step for the integration\n        metric: function defining the metric tensor on the manifold\n        n_steps: number of steps to integrate for\n\n    Returns:\n        exp_map: function for computing exponential map\n    \"\"\"\n\n    if not n_steps:\n        n_steps = int(1.0 // dt)\n\n    dynamics = jtu.Partial(geodesic_dynamics, metric=metric)\n    ivp_params = ParametersIVP(differential_operator=dynamics, dt=dt, n_steps=n_steps)\n\n    @_integrator_to_exp\n    def exp_map(state: TangentSpace[jax.Array]) -&gt; tuple[TangentSpace[jax.Array], TangentSpace[jax.Array]]:\n        return integrator(ivp_params, state)\n\n    return exp_map\n</code></pre>"},{"location":"manifold/maps/#riemax.manifold.maps.symplectic_exponential_map_factory","title":"<code>riemax.manifold.maps.symplectic_exponential_map_factory(integrator: LagrangianSymplecticIntegrator, dt: float, omega: float, metric: MetricFn, n_steps: int | None = None) -&gt; ExponentialMap</code>","text":"<p>Produce an exponential map, \\(\\exp: TM \\rightarrow M\\), using symplectic dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>riemax.manifold.symplectic.LagrangianSymplecticIntegrator</code> <p>choice of Lagrangian symplectic integrator used to propgate dynamics</p> required <code>dt</code> <code>float</code> <p>time-step for the integration</p> required <code>omega</code> <code>float</code> <p>strength of the constraint between the phase-split copies</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <code>n_steps</code> <code>int | None</code> <p>number of steps to integrate for</p> <code>None</code> <p>Returns:</p> Name Type Description <code>exp_map</code> <code>ExponentialMap</code> <p>function for computing exponential map</p> Source code in <code>src/riemax/manifold/maps.py</code> <pre><code>def symplectic_exponential_map_factory(\n    integrator: LagrangianSymplecticIntegrator, dt: float, omega: float, metric: MetricFn, n_steps: int | None = None\n) -&gt; ExponentialMap:\n    r\"\"\"Produce an exponential map, $\\exp: TM \\rightarrow M$, using symplectic dynamics.\n\n    Parameters:\n        integrator: choice of Lagrangian symplectic integrator used to propgate dynamics\n        dt: time-step for the integration\n        omega: strength of the constraint between the phase-split copies\n        metric: function defining the metric tensor on the manifold\n        n_steps: number of steps to integrate for\n\n    Returns:\n        exp_map: function for computing exponential map\n    \"\"\"\n\n    if not n_steps:\n        n_steps = int(1.0 // dt)\n\n    symplectic_params = SymplecticParams(metric=metric, dt=dt, omega=omega, n_steps=n_steps)\n\n    @_integrator_to_exp\n    def exp_map(state: TangentSpace[jax.Array]) -&gt; tuple[TangentSpace[jax.Array], TangentSpace[jax.Array]]:\n        return integrator(symplectic_params, state)\n\n    return exp_map\n</code></pre>"},{"location":"manifold/maps/#riemax.manifold.maps.shooting_log_map_factory","title":"<code>riemax.manifold.maps.shooting_log_map_factory(exp_map: ExponentialMap, nr_parameters: NewtonRaphsonParams | None = None) -&gt; LogMap</code>","text":"<p>Produce log map, computed using a shooting method.</p> <p>Efficacy of Shooting Solvers:</p> <p>Shooting solvers typically require a good initial guess. If the initial guess for the velocity vector is too far from a true solution, this can tend to fail. We also note that, this does not guarantee obtaining the velocity vector of the globally length-minimising geodesic -- only of a valid geodesic which connects the two points.</p> <p>Parameters:</p> Name Type Description Default <code>exp_map</code> <code>ExponentialMap</code> <p>function used to compute the exponential map</p> required <code>nr_parameters</code> <code>riemax.numerical.newton_raphson.NewtonRaphsonParams | None</code> <p>parameters used in the Newton-Raphson optimisation</p> <code>None</code> <p>Returns:</p> Name Type Description <code>log_map</code> <code>LogMap</code> <p>function to compute the log map between \\(p, q \\in M\\)</p> Source code in <code>src/riemax/manifold/maps.py</code> <pre><code>def shooting_log_map_factory(exp_map: ExponentialMap, nr_parameters: NewtonRaphsonParams | None = None) -&gt; LogMap:\n    r\"\"\"Produce log map, computed using a shooting method.\n\n    !!! note \"Efficacy of Shooting Solvers:\"\n\n        Shooting solvers typically require a good initial guess. If the initial guess for the velocity vector is too far\n        from a true solution, this can tend to fail. We also note that, this does not guarantee obtaining the velocity\n        vector of the globally length-minimising geodesic -- only of a valid geodesic which connects the two points.\n\n    Parameters:\n        exp_map: function used to compute the exponential map\n        nr_parameters: parameters used in the Newton-Raphson optimisation\n\n    Returns:\n        log_map: function to compute the log map between $p, q \\in M$\n    \"\"\"\n\n    def log_map(\n        p: TangentSpace[jax.Array] | M[jax.Array],\n        q: M[jax.Array],\n    ) -&gt; tuple[TangentSpace[jax.Array], bool]:\n        \"\"\"Compute the log map between points p and q.\n\n        Parameters:\n            p: origin point on the manifold\n            q: destination point on the manifold\n            initial_p0_dot: initial guess for the tangent vector\n\n        Returns:\n            state which, when the exponential map is taken at p, yields q\n        \"\"\"\n\n        if not isinstance(p, TangentSpace):\n            p = TangentSpace(point=p, vector=(q - p))\n\n        def shooting_residual(p_dot: TpM[jax.Array]) -&gt; TpM[jax.Array]:\n            initial_state = TangentSpace[jax.Array](point=p.point, vector=p_dot)\n            point, _ = exp_map(initial_state)\n\n            return point - q\n\n        # root-finding for shooting residual\n        p_dot, newton_convergence_state = newton_raphson(\n            shooting_residual, initial_guess=p.vector, nr_parameters=nr_parameters\n        )\n\n        initial_condition = TangentSpace[jax.Array](point=p.point, vector=p_dot)\n\n        return initial_condition, newton_convergence_state.converged\n\n    return log_map\n</code></pre>"},{"location":"manifold/maps/#riemax.manifold.maps.minimising_log_map_factory","title":"<code>riemax.manifold.maps.minimising_log_map_factory(metric: MetricFn, optimiser: optax.GradientTransformation, num_nodes: int = 20, n_collocation: int = 100, iterations: int = 100, tol: float = 0.0001) -&gt; LogMap</code>","text":"<p>Produce a log-map using an energy-minimising approach.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <code>optimiser</code> <code>optax.GradientTransformation</code> <p>optimiser to use to minimise energy of the curve</p> required <code>num_nodes</code> <code>int</code> <p>number of nodes to use to parameterise cubic spline</p> <code>20</code> <code>n_collocation</code> <code>int</code> <p>number of points at which to evaluate energy along the curve</p> <code>100</code> <code>iterations</code> <code>int</code> <p>number of iterations to optimise for</p> <code>100</code> <code>tol</code> <code>float</code> <p>tolerance for measuring convergence</p> <code>0.0001</code> <p>Returns:</p> Name Type Description <code>log_map</code> <code>LogMap</code> <p>function to compute the log map between \\(p, q \\in M\\)</p> Source code in <code>src/riemax/manifold/maps.py</code> <pre><code>def minimising_log_map_factory(\n    metric: MetricFn,\n    optimiser: optax.GradientTransformation,\n    num_nodes: int = 20,\n    n_collocation: int = 100,\n    iterations: int = 100,\n    tol: float = 1e-4,\n) -&gt; LogMap:\n    r\"\"\"Produce a log-map using an energy-minimising approach.\n\n    Parameters:\n        metric: function defining the metric tensor on the manifold\n        optimiser: optimiser to use to minimise energy of the curve\n        num_nodes: number of nodes to use to parameterise cubic spline\n        n_collocation: number of points at which to evaluate energy along the curve\n        iterations: number of iterations to optimise for\n        tol: tolerance for measuring convergence\n\n    Returns:\n        log_map: function to compute the log map between $p, q \\in M$\n    \"\"\"\n\n    def log_map(p: TangentSpace[jax.Array] | M[jax.Array], q: M[jax.Array]) -&gt; tuple[TangentSpace[jax.Array], bool]:\n        \"\"\"Compute the log map between points p and q.\n\n        Parameters:\n            p: origin point on the manifold\n            q: destination point on the manifold\n\n        Returns:\n            state which, when the exponential map is taken at p, yields q\n        \"\"\"\n\n        if isinstance(p, TangentSpace):\n            p = p.point\n\n        geodesic, converged = minimising_geodesic(\n            p=p,\n            q=q,\n            metric=metric,\n            optimiser=optimiser,\n            num_nodes=num_nodes,\n            n_collocation=n_collocation,\n            iterations=iterations,\n            tol=tol,\n        )\n\n        return TangentSpace(point=geodesic.point[0], vector=geodesic.vector[0]), converged\n\n    return log_map\n</code></pre>"},{"location":"manifold/maps/#riemax.manifold.maps.scipy_bvp_log_map_factory","title":"<code>riemax.manifold.maps.scipy_bvp_log_map_factory(metric: MetricFn, n_collocation: int = 100, explicit_jacobian: bool = False, tol: float = 0.0001) -&gt; LogMap</code>","text":"<p>Produce a log-map using scipy solve_bvp approach.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <code>n_collocation</code> <code>int</code> <p>number of points at which to evaluate energy along the curve</p> <code>100</code> <code>explicit_jacobian</code> <code>bool</code> <p>whether to use the jacobian compute by jax</p> <code>False</code> <code>tol</code> <code>float</code> <p>tolerance for measuring convergence</p> <code>0.0001</code> <p>Returns:</p> Name Type Description <code>log_map</code> <code>LogMap</code> <p>function to compute the log map between \\(p, q \\in M\\)</p> Source code in <code>src/riemax/manifold/maps.py</code> <pre><code>def scipy_bvp_log_map_factory(\n    metric: MetricFn, n_collocation: int = 100, explicit_jacobian: bool = False, tol: float = 1e-4\n) -&gt; LogMap:\n    r\"\"\"Produce a log-map using scipy solve_bvp approach.\n\n    Parameters:\n        metric: function defining the metric tensor on the manifold\n        n_collocation: number of points at which to evaluate energy along the curve\n        explicit_jacobian: whether to use the jacobian compute by jax\n        tol: tolerance for measuring convergence\n\n    Returns:\n        log_map: function to compute the log map between $p, q \\in M$\n    \"\"\"\n\n    def log_map(p: TangentSpace[jax.Array] | M[jax.Array], q: M[jax.Array]) -&gt; tuple[TangentSpace[jax.Array], bool]:\n        \"\"\"Compute the log map between points p and q.\n\n        Parameters:\n            p: origin point on the manifold\n            q: destination point on the manifold\n\n        Returns:\n            state which, when the exponential map is taken at p, yields q\n        \"\"\"\n\n        if isinstance(p, TangentSpace):\n            p = p.point\n\n        geodesic, converged = scipy_bvp_geodesic(\n            p=p, q=q, metric=metric, n_collocation=n_collocation, explicit_jacobian=explicit_jacobian, tol=tol\n        )\n\n        return TangentSpace(point=geodesic.point[0], vector=geodesic.vector[0]), converged\n\n    return log_map\n</code></pre>"},{"location":"manifold/operators/","title":"Operators","text":"<p>In many cases, we wish to define operators on the manifold. Most notably, we are interested in being able to compute the exterior derivative (gradient), the divergence, and the Laplacian.</p> <p>Coming soon...</p> <p>We also need to add the ability to compute the curl on the manifold.</p>"},{"location":"manifold/operators/#src.riemax.operators","title":"<code>src.riemax.operators</code>","text":""},{"location":"manifold/operators/#src.riemax.operators.grad","title":"<code>src.riemax.operators.grad(fn: tp.Callable[[M[jax.Array]], jax.Array], metric: MetricFn) -&gt; tp.Callable[[M[jax.Array]], jax.Array]</code>","text":"<p>Compute gradient of scalar function on the manifold.</p> <p>When an inner product \\(\\langle \\cdot, \\cdot \\rangle\\) is defined, the gradient \\(\\nabla f\\) of a function \\(f\\) is defined as the unique vector \\(V\\) such that its inner product with any element of \\(V\\) is the directional derivative of \\(f\\) along the vector.<sup>1</sup><sup>2</sup> Precisely</p> \\[ \\langle \\nabla f, \\cdot \\rangle = df = \\partial_i f dx^i, \\] <p>this yields</p> \\[ \\nabla f = (df)^\\sharp = g^{ij} \\partial_j f \\] <p>The 1-form \\(df\\) is a section of the cotangent bundle, giving a local linear approximation to \\(f\\) in the cotangent space at each point.</p> <p>Example:</p> <p>Given a scalar function \\(f\\), we can define the gradient as</p> <pre><code># ...\n\ndef scalar_fn(p: jax.Array) -&gt; jax.Array:\n    return jnp.sum(jnp.square(p))\n\nfn_grad = riemax.manifold.operators.grad(scalar_fn, fn_metric)\n</code></pre> <ol> <li> <p>Carmo, Manfredo Perdig\u00e3o do. Riemannian Geometry. 2013.\u00a0\u21a9</p> </li> <li> <p>Lee, John M. Introduction to Riemannian Manifolds. 2018.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>typing.Callable[[src.riemax.manifold.types.M[jax.Array]], jax.Array]</code> <p>scalar function to take derivative of</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Name Type Description <code>transformed</code> <code>typing.Callable[[src.riemax.manifold.types.M[jax.Array]], jax.Array]</code> <p>function which takes gradient of scalar function on the manifold</p> Source code in <code>src/riemax/manifold/operators.py</code> <pre><code>@manifold_marker.mark(jittable=False)\ndef grad(fn: tp.Callable[[M[jax.Array]], jax.Array], metric: MetricFn) -&gt; tp.Callable[[M[jax.Array]], jax.Array]:\n    r\"\"\"Compute gradient of scalar function on the manifold.\n\n    When an inner product $\\langle \\cdot, \\cdot \\rangle$ is defined, the gradient $\\nabla f$ of a function $f$ is\n    defined as the unique vector $V$ such that its inner product with any element of $V$ is the directional derivative\n    of $f$ along the vector.[^1][^2] Precisely\n\n    $$\n    \\langle \\nabla f, \\cdot \\rangle = df = \\partial_i f dx^i,\n    $$\n\n    this yields\n\n    $$\n    \\nabla f = (df)^\\sharp = g^{ij} \\partial_j f\n    $$\n\n    The 1-form $df$ is a section of the cotangent bundle, giving a local linear approximation to $f$ in the cotangent\n    space at each point.\n\n    **Example:**\n\n    Given a scalar function $f$, we can define the gradient as\n\n    ```python\n    # ...\n\n    def scalar_fn(p: jax.Array) -&gt; jax.Array:\n        return jnp.sum(jnp.square(p))\n\n    fn_grad = riemax.manifold.operators.grad(scalar_fn, fn_metric)\n    ```\n\n    [^1]: Carmo, Manfredo Perdig\u00e3o do. Riemannian Geometry. 2013.\n    [^2]: Lee, John M. Introduction to Riemannian Manifolds. 2018.\n\n    Parameters:\n        fn: scalar function to take derivative of\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        transformed: function which takes gradient of scalar function on the manifold\n    \"\"\"\n\n    @ft.wraps(fn)\n    def transformed(x: M[jax.Array]) -&gt; jax.Array:\n        co_gx = metric(x)\n        contra_gx = jnp.linalg.inv(co_gx)\n\n        fn_j = jax.jacfwd(fn)(x)\n\n        return jnp.einsum('ij, ...j -&gt; i', contra_gx, fn_j)\n\n    return transformed\n</code></pre>"},{"location":"manifold/operators/#src.riemax.operators.div","title":"<code>src.riemax.operators.div(fn: tp.Callable[[M[jax.Array]], jax.Array], metric: MetricFn) -&gt; tp.Callable[[M[jax.Array]], jax.Array]</code>","text":"<p>Compute divergence of vector-valued function on the manifold.</p> <p>Given a vector field \\(X \\in TM\\), we define the divergence as<sup>1</sup><sup>2</sup></p> \\[ \\nabla \\cdot X = \\lvert g \\rvert^{-\\frac{1}{2}} \\partial_i \\left( \\lvert g \\rvert^{\\frac{1}{2}} X^i \\right) \\] <ol> <li> <p>Carmo, Manfredo Perdig\u00e3o do. Riemannian Geometry. 2013.\u00a0\u21a9</p> </li> <li> <p>Lee, John M. Introduction to Riemannian Manifolds. 2018.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>typing.Callable[[src.riemax.manifold.types.M[jax.Array]], jax.Array]</code> <p>vector function to compute divergence of</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Name Type Description <code>transformed</code> <code>typing.Callable[[src.riemax.manifold.types.M[jax.Array]], jax.Array]</code> <p>Function which computes divergence of vector-valued function on the manifold</p> Source code in <code>src/riemax/manifold/operators.py</code> <pre><code>@manifold_marker.mark(jittable=False)\ndef div(fn: tp.Callable[[M[jax.Array]], jax.Array], metric: MetricFn) -&gt; tp.Callable[[M[jax.Array]], jax.Array]:\n    r\"\"\"Compute divergence of vector-valued function on the manifold.\n\n    Given a vector field $X \\in TM$, we define the divergence as[^1][^2]\n\n    $$\n    \\nabla \\cdot X = \\lvert g \\rvert^{-\\frac{1}{2}} \\partial_i \\left( \\lvert g \\rvert^{\\frac{1}{2}} X^i \\right)\n    $$\n\n    [^1]: Carmo, Manfredo Perdig\u00e3o do. Riemannian Geometry. 2013.\n    [^2]: Lee, John M. Introduction to Riemannian Manifolds. 2018.\n\n    Parameters:\n        fn: vector function to compute divergence of\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        transformed: Function which computes divergence of vector-valued function on the manifold\n    \"\"\"\n\n    @ft.wraps(fn)\n    def transformed(x: M[jax.Array]) -&gt; jax.Array:\n        co_gx = metric(x)\n        sqrt_det_co_gx = jnp.sqrt(jnp.linalg.det(co_gx))\n\n        def _inner(_x: M[jax.Array]) -&gt; jax.Array:\n            co_gx_inner = metric(_x)\n            sqrt_det_co_gx_inner = jnp.sqrt(jnp.linalg.det(co_gx_inner))\n\n            val = sqrt_det_co_gx_inner * fn(_x)\n\n            if val.ndim == 0:\n                raise ValueError('div only defined for vector fields.')\n\n            return val\n\n        inner_i = jax.jacfwd(_inner)(x)\n\n        return jnp.einsum('ii -&gt; ', inner_i) / sqrt_det_co_gx\n\n    return transformed\n</code></pre>"},{"location":"manifold/operators/#src.riemax.operators.laplace_beltrami","title":"<code>src.riemax.operators.laplace_beltrami(fn: tp.Callable[[M[jax.Array]], jax.Array], metric: MetricFn) -&gt; tp.Callable[[M[jax.Array]], jax.Array]</code>","text":"<p>Compute laplacian of scalar-valued function on the manifold.</p> <p>Given a function \\(f: M \\rightarrow \\mathbb{R}\\), we can compute the Laplacian by taking the divergence of the exterior derivative.<sup>1</sup><sup>2</sup> Precisely, we can compute</p> \\[ \\Delta X = \\lvert g \\rvert^{-\\frac{1}{2}} \\partial_i \\left( \\lvert g \\rvert^{\\frac{1}{2}} g^{ij} \\partial_j f \\right) \\] <ol> <li> <p>Carmo, Manfredo Perdig\u00e3o do. Riemannian Geometry. 2013.\u00a0\u21a9</p> </li> <li> <p>Lee, John M. Introduction to Riemannian Manifolds. 2018.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>typing.Callable[[src.riemax.manifold.types.M[jax.Array]], jax.Array]</code> <p>scalar function to compute laplacian of</p> required <code>metric</code> <code>src.riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Name Type Description <code>transformed</code> <code>typing.Callable[[src.riemax.manifold.types.M[jax.Array]], jax.Array]</code> <p>Function which computes laplacian of scalar-valued functions on the manifold.</p> Source code in <code>src/riemax/manifold/operators.py</code> <pre><code>@manifold_marker.mark(jittable=False)\ndef laplace_beltrami(\n    fn: tp.Callable[[M[jax.Array]], jax.Array], metric: MetricFn\n) -&gt; tp.Callable[[M[jax.Array]], jax.Array]:\n    r\"\"\"Compute laplacian of scalar-valued function on the manifold.\n\n    Given a function $f: M \\rightarrow \\mathbb{R}$, we can compute the Laplacian by taking the divergence of the\n    exterior derivative.[^1][^2] Precisely, we can compute\n\n    $$\n    \\Delta X = \\lvert g \\rvert^{-\\frac{1}{2}} \\partial_i \\left( \\lvert g \\rvert^{\\frac{1}{2}} g^{ij} \\partial_j f \\right)\n    $$\n\n    [^1]: Carmo, Manfredo Perdig\u00e3o do. Riemannian Geometry. 2013.\n    [^2]: Lee, John M. Introduction to Riemannian Manifolds. 2018.\n\n    Parameters:\n        fn: scalar function to compute laplacian of\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        transformed: Function which computes laplacian of scalar-valued functions on the manifold.\n    \"\"\"\n\n    @ft.wraps(fn)\n    def transformed(x: M[jax.Array]) -&gt; jax.Array:\n        return div(grad(fn, metric), metric)(x)\n\n    return transformed\n</code></pre>"},{"location":"manifold/symplectic/","title":"symplectic","text":"<p>The geodesic equation is usually solved in the classic Lagrangian form, however it also admits a Hamiltonian. This hamiltonian is non-separable, meaning that standard methods for integration are not feasible. Recently, an approach for integration of non-separable Hamiltonians has been developed, doubling the phase-space and evolving states in parallel.<sup>1</sup><sup>2</sup><sup>3</sup> Riemax provides an implementation of this approach for defining dynamics of geodesics upto arbitrary orders of integration.</p> <p>Additional documentation required.</p> <p>This documentation requires further explanation of the method for integration of non-separable Hamiltonians. This page will be updated in future iterations of the documentation to make the process as clear as possible.</p> <ol> <li> <p>Christian, Pierre, and Chi-kwan Chan. \u2018FANTASY: User-Friendly Symplectic Geodesic Integrator for Arbitrary Metrics with Automatic Differentiation\u2019. The Astrophysical Journal 909, 2021. https://doi.org/10.3847/1538-4357/abdc28 \u21a9</p> </li> <li> <p>Tao, Molei. \u2018Explicit Symplectic Approximation of Nonseparable Hamiltonians: Algorithm and Long Time Performance\u2019. Physical Review E 94, 2016. https://doi.org/10.1103/PhysRevE.94.043303 \u21a9</p> </li> <li> <p>Yoshida, Haruo. \u2018Construction of Higher Order Symplectic Integrators\u2019. Physics Letters A, 1990. https://doi.org/10.1016/0375-9601(90)90092-3 \u21a9</p> </li> </ol>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic","title":"<code>riemax.manifold.symplectic</code>","text":""},{"location":"manifold/symplectic/#riemax.manifold.symplectic.SymplecticGeodesicState","title":"<code>riemax.manifold.symplectic.SymplecticGeodesicState</code>","text":"<p>             Bases: <code>typing.NamedTuple</code></p> <p>PyTree for Symplectic Geodesic State.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <p>position on the geodesic</p> required <code>p</code> <p>conjugate momenta on the co-tangent space</p> required Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>class SymplecticGeodesicState(tp.NamedTuple):\n\n    \"\"\"PyTree for Symplectic Geodesic State.\n\n    Parameters:\n        q: position on the geodesic\n        p: conjugate momenta on the co-tangent space\n    \"\"\"\n\n    q: jax.Array\n    p: jax.Array\n\n    @classmethod\n    def from_lagrangian(cls, state: TangentSpace[jax.Array], metric: MetricFn) -&gt; SymplecticGeodesicState:\n        \"\"\"Build Hamiltonian symplectic state from given Lagrangian state.\n\n        Parameters:\n            state: Geodesic state in Lagrangian coordinates.\n            metric: Function used to evaluate the metric.\n\n        Returns:\n            Symplectic state in Hamiltonian coordinates.\n        \"\"\"\n\n        conjugate_momenta = jnp.einsum('...ij, ...j -&gt; ...i', metric(state.point), state.vector)\n        return cls(q=state.point, p=conjugate_momenta)\n\n    def to_lagrangian(self, metric: MetricFn) -&gt; TangentSpace[jax.Array]:\n        \"\"\"Convert intrinstic Hamiltonian coordinates to Lagrangian coordinates.\n\n        Parameters:\n            metric: Function used to evaluate the metric.\n\n        Returns:\n            Geodesic state in Lagrangian coordinates.\n        \"\"\"\n\n        velocity = jnp.einsum('...ij, ...j -&gt; ...i', contravariant_metric_tensor(self.q, metric), self.p)\n        return TangentSpace(point=self.q, vector=velocity)\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.SymplecticGeodesicState.from_lagrangian","title":"<code>from_lagrangian(state: TangentSpace[jax.Array], metric: MetricFn) -&gt; SymplecticGeodesicState</code>  <code>classmethod</code>","text":"<p>Build Hamiltonian symplectic state from given Lagrangian state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>Geodesic state in Lagrangian coordinates.</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>Function used to evaluate the metric.</p> required <p>Returns:</p> Type Description <code>riemax.manifold.symplectic.SymplecticGeodesicState</code> <p>Symplectic state in Hamiltonian coordinates.</p> Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>@classmethod\ndef from_lagrangian(cls, state: TangentSpace[jax.Array], metric: MetricFn) -&gt; SymplecticGeodesicState:\n    \"\"\"Build Hamiltonian symplectic state from given Lagrangian state.\n\n    Parameters:\n        state: Geodesic state in Lagrangian coordinates.\n        metric: Function used to evaluate the metric.\n\n    Returns:\n        Symplectic state in Hamiltonian coordinates.\n    \"\"\"\n\n    conjugate_momenta = jnp.einsum('...ij, ...j -&gt; ...i', metric(state.point), state.vector)\n    return cls(q=state.point, p=conjugate_momenta)\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.SymplecticGeodesicState.to_lagrangian","title":"<code>to_lagrangian(metric: MetricFn) -&gt; TangentSpace[jax.Array]</code>","text":"<p>Convert intrinstic Hamiltonian coordinates to Lagrangian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>Function used to evaluate the metric.</p> required <p>Returns:</p> Type Description <code>riemax.manifold.types.TangentSpace[jax.Array]</code> <p>Geodesic state in Lagrangian coordinates.</p> Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>def to_lagrangian(self, metric: MetricFn) -&gt; TangentSpace[jax.Array]:\n    \"\"\"Convert intrinstic Hamiltonian coordinates to Lagrangian coordinates.\n\n    Parameters:\n        metric: Function used to evaluate the metric.\n\n    Returns:\n        Geodesic state in Lagrangian coordinates.\n    \"\"\"\n\n    velocity = jnp.einsum('...ij, ...j -&gt; ...i', contravariant_metric_tensor(self.q, metric), self.p)\n    return TangentSpace(point=self.q, vector=velocity)\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.PhaseDoubledSymplecticGeodesicState","title":"<code>riemax.manifold.symplectic.PhaseDoubledSymplecticGeodesicState</code>","text":"<p>             Bases: <code>typing.NamedTuple</code></p> <p>PyTree for the phase-doubled Symplectic Geodesic State</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <p>position on the geodesic</p> required <code>p</code> <p>conjugate momenta on the co-tangent space</p> required <code>x</code> <p>phase-doubled position on the geodesic</p> required <code>y</code> <p>phase-doubled conjugate momenta on the co-tangent space</p> required Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>class PhaseDoubledSymplecticGeodesicState(tp.NamedTuple):\n\n    \"\"\"PyTree for the phase-doubled Symplectic Geodesic State\n\n    Parameters:\n        q: position on the geodesic\n        p: conjugate momenta on the co-tangent space\n        x: phase-doubled position on the geodesic\n        y: phase-doubled conjugate momenta on the co-tangent space\n    \"\"\"\n\n    q: jax.Array\n    p: jax.Array\n    x: jax.Array\n    y: jax.Array\n\n    @classmethod\n    def from_symplectic(cls, state: SymplecticGeodesicState) -&gt; PhaseDoubledSymplecticGeodesicState:\n        \"\"\"Build phase-doubled symplectic state from given symplectic state.\n\n        Parameters:\n            state: Symplectic state in a single phase-space.\n\n        Returns:\n            Phase-doubled symplectic state, replicating state in new phase-space.\n        \"\"\"\n\n        return cls(q=state.q, p=state.p, x=state.q, y=state.p)\n\n    def to_symplectic(self) -&gt; SymplecticGeodesicState:\n        \"\"\"Transform phase-doubled symplectic state to a single-phase symplectic state.\n\n        Returns:\n            Single-phase symplectic state -- removing phase-doubling.\n        \"\"\"\n\n        return SymplecticGeodesicState(q=self.q, p=self.p)\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.PhaseDoubledSymplecticGeodesicState.from_symplectic","title":"<code>from_symplectic(state: SymplecticGeodesicState) -&gt; PhaseDoubledSymplecticGeodesicState</code>  <code>classmethod</code>","text":"<p>Build phase-doubled symplectic state from given symplectic state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>riemax.manifold.symplectic.SymplecticGeodesicState</code> <p>Symplectic state in a single phase-space.</p> required <p>Returns:</p> Type Description <code>riemax.manifold.symplectic.PhaseDoubledSymplecticGeodesicState</code> <p>Phase-doubled symplectic state, replicating state in new phase-space.</p> Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>@classmethod\ndef from_symplectic(cls, state: SymplecticGeodesicState) -&gt; PhaseDoubledSymplecticGeodesicState:\n    \"\"\"Build phase-doubled symplectic state from given symplectic state.\n\n    Parameters:\n        state: Symplectic state in a single phase-space.\n\n    Returns:\n        Phase-doubled symplectic state, replicating state in new phase-space.\n    \"\"\"\n\n    return cls(q=state.q, p=state.p, x=state.q, y=state.p)\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.PhaseDoubledSymplecticGeodesicState.to_symplectic","title":"<code>to_symplectic() -&gt; SymplecticGeodesicState</code>","text":"<p>Transform phase-doubled symplectic state to a single-phase symplectic state.</p> <p>Returns:</p> Type Description <code>riemax.manifold.symplectic.SymplecticGeodesicState</code> <p>Single-phase symplectic state -- removing phase-doubling.</p> Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>def to_symplectic(self) -&gt; SymplecticGeodesicState:\n    \"\"\"Transform phase-doubled symplectic state to a single-phase symplectic state.\n\n    Returns:\n        Single-phase symplectic state -- removing phase-doubling.\n    \"\"\"\n\n    return SymplecticGeodesicState(q=self.q, p=self.p)\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.SymplecticParams","title":"<code>riemax.manifold.symplectic.SymplecticParams</code>","text":"<p>             Bases: <code>typing.NamedTuple</code></p> <p>Contained for parameters of symplectic integration</p> <p>Parameters:</p> Name Type Description Default <code>metric</code> <p>function defining the metric tensor on the manifold</p> required <code>dt</code> <p>time-step used for the integration</p> required <code>omega</code> <p>strength of the constraint between the phase-split copies</p> required <code>n_steps</code> <p>number of steps to integrate for</p> required Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>class SymplecticParams(tp.NamedTuple):\n\n    \"\"\"Contained for parameters of symplectic integration\n\n    Parameters:\n        metric: function defining the metric tensor on the manifold\n        dt: time-step used for the integration\n        omega: strength of the constraint between the phase-split copies\n        n_steps: number of steps to integrate for\n    \"\"\"\n\n    metric: MetricFn\n    dt: float = 1e-3\n    omega: float = 1e-2\n    n_steps: int = int(1e3)\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.hamiltonian","title":"<code>riemax.manifold.symplectic.hamiltonian(q: jax.Array, conjugate_momenta: jax.Array, metric: MetricFn) -&gt; jax.Array</code>","text":"<p>Computes the Hamiltonian of the state.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>jax.Array</code> <p>position on the geodesic</p> required <code>conjugate_momenta</code> <code>jax.Array</code> <p>conjugate momenta of the geodesic path</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Type Description <code>jax.Array</code> <p>hamiltonian of the geodesic</p> Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>def hamiltonian(q: jax.Array, conjugate_momenta: jax.Array, metric: MetricFn) -&gt; jax.Array:\n    \"\"\"Computes the Hamiltonian of the state.\n\n    Parameters:\n        q: position on the geodesic\n        conjugate_momenta: conjugate momenta of the geodesic path\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        hamiltonian of the geodesic\n    \"\"\"\n\n    fn_contra_gx = jtu.Partial(contravariant_metric_tensor, metric=metric)\n    return 0.5 * jnp.einsum('ij, i, j -&gt; ', fn_contra_gx(q), conjugate_momenta, conjugate_momenta)\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.second_order_dynamics","title":"<code>riemax.manifold.symplectic.second_order_dynamics(state: PhaseDoubledSymplecticGeodesicState, dt: float, omega: float, metric: MetricFn) -&gt; PhaseDoubledSymplecticGeodesicState</code>","text":"<p>Conduct time-step using second-order dynamics.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>riemax.manifold.symplectic.PhaseDoubledSymplecticGeodesicState</code> <p>current state of the symplectic integrator</p> required <code>dt</code> <code>float</code> <p>time-step used for the integration</p> required <code>omega</code> <code>float</code> <p>strength of the constraint between the phase-split copies</p> required <code>metric</code> <code>riemax.manifold.types.MetricFn</code> <p>function defining the metric tensor on the manifold</p> required <p>Returns:</p> Name Type Description <code>state</code> <code>riemax.manifold.symplectic.PhaseDoubledSymplecticGeodesicState</code> <p>time-stepped, phase-doubled symplectic geodesic state</p> Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>def second_order_dynamics(\n    state: PhaseDoubledSymplecticGeodesicState, dt: float, omega: float, metric: MetricFn\n) -&gt; PhaseDoubledSymplecticGeodesicState:\n    \"\"\"Conduct time-step using second-order dynamics.\n\n    Parameters:\n        state: current state of the symplectic integrator\n        dt: time-step used for the integration\n        omega: strength of the constraint between the phase-split copies\n        metric: function defining the metric tensor on the manifold\n\n    Returns:\n        state: time-stepped, phase-doubled symplectic geodesic state\n    \"\"\"\n\n    fn_phi_ha = jtu.Partial(_phi_ha, dt=dt, metric=metric)\n    fn_phi_hb = jtu.Partial(_phi_hb, dt=dt, metric=metric)\n    fn_phi_hc = jtu.Partial(_phi_hc, dt=dt, omega=omega)\n\n    state = fn_phi_ha(state=state)\n    state = fn_phi_hb(state=state)\n    state = fn_phi_hc(state=state)\n    state = fn_phi_hb(state=state)\n    state = fn_phi_ha(state=state)\n\n    return state\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.construct_nth_order_dynamics","title":"<code>riemax.manifold.symplectic.construct_nth_order_dynamics(n: int)</code>","text":"<p>Construct nth order symplectic dynamics.</p> <p>Recursive definition:</p> <p>Function works recursively, producing additional phase-maps as required.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>order of integration to produce</p> required <p>Returns:</p> Type Description <p>function to compute nth order dynamics</p> Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>def construct_nth_order_dynamics(n: int):\n    \"\"\"Construct nth order symplectic dynamics.\n\n    !!! note \"Recursive definition:\"\n        Function works recursively, producing additional phase-maps as required.\n\n    Parameters:\n        n: order of integration to produce\n\n    Returns:\n        function to compute nth order dynamics\n    \"\"\"\n\n    if not n % 2 == 0:\n        raise ValueError('Only works for even n.')\n\n    @ft.lru_cache()\n    def _construct(n: int):\n        if n == 2:\n            return second_order_dynamics\n\n        def nth_order_dynamics(state, dt, omega, metric):\n            _n = (n - 2) // 2\n            z0, z1 = _yoshida_triple_jump_constants(n=_n)\n\n            nmt_dynamics = _construct(n - 2)\n            fn_phi_a = jtu.Partial(nmt_dynamics, dt=(z1 * dt), omega=omega, metric=metric)\n            fn_phi_b = jtu.Partial(nmt_dynamics, dt=(z0 * dt), omega=omega, metric=metric)\n\n            state = fn_phi_a(state=state)\n            state = fn_phi_b(state=state)\n            state = fn_phi_a(state=state)\n\n            return state\n\n        return nth_order_dynamics\n\n    return _construct(n)\n</code></pre>"},{"location":"manifold/symplectic/#riemax.manifold.symplectic.construct_nth_order_symplectic_integrator","title":"<code>riemax.manifold.symplectic.construct_nth_order_symplectic_integrator(n: int) -&gt; PhaseDoubledSymplecticIntegrator</code>","text":"<p>Construct symplectic integrator of the nth order.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>order of integration required</p> required <p>Returns:</p> Type Description <code>riemax.manifold.symplectic.PhaseDoubledSymplecticIntegrator</code> <p>integrator for phase-doubled symplectic state</p> Source code in <code>src/riemax/manifold/symplectic.py</code> <pre><code>def construct_nth_order_symplectic_integrator(n: int) -&gt; PhaseDoubledSymplecticIntegrator:\n    \"\"\"Construct symplectic integrator of the nth order.\n\n    Parameters:\n        n: order of integration required\n\n    Returns:\n        integrator for phase-doubled symplectic state\n    \"\"\"\n\n    def _nth_order_symplectic_integrator(\n        symplectic_params: SymplecticParams, initial_state: PhaseDoubledSymplecticGeodesicState\n    ) -&gt; tuple[PhaseDoubledSymplecticGeodesicState, PhaseDoubledSymplecticGeodesicState]:\n        \"\"\"Integrator using nth order symplectic dynamics.\n\n        Parameters:\n            symplectic_params: parameters for the symplectic integration\n            initial_state: state at t=0\n        \"\"\"\n\n        nth_order_dynamics = construct_nth_order_dynamics(n)\n        fn_updator = jtu.Partial(\n            nth_order_dynamics, dt=symplectic_params.dt, omega=symplectic_params.omega, metric=symplectic_params.metric\n        )\n\n        def _single_step(\n            state: PhaseDoubledSymplecticGeodesicState, _: None\n        ) -&gt; tuple[PhaseDoubledSymplecticGeodesicState, PhaseDoubledSymplecticGeodesicState]:\n            return fn_updator(state=state), state\n\n        final_state, preceding_states = jax.lax.scan(_single_step, initial_state, None, symplectic_params.n_steps)\n        full_state = _merge_states(preceding=preceding_states, final=final_state)\n\n        return final_state, full_state\n\n    return _nth_order_symplectic_integrator\n</code></pre>"},{"location":"numerical/curves/","title":"curves","text":"<p>We provide an implementation of cubic-splines, parameterised by their null-space. The cubic spline is constrained at two end-points, and the basis of the null space is used to parameterise the curve itself.</p> <p>Rational for Parameterisation:</p> <p>In short, equations for cubic splines form a system of linear homogeneous equations</p> \\[ \\mathbf{A} \\mathbf{x} = \\mathbf{0} \\] <p>We also know the solution set can be described as</p> \\[ \\{ \\mathbf{p} + \\mathbf{v} : \\mathbf{v} \\text{ is any solution to } \\mathbf{A}\\mathbf{x} = \\mathbf{0} \\} \\] <p>If we consider elements of the null-basis \\(\\mathbf{\\varphi} \\in N(A)\\), we see</p> \\[ \\mathbf{A}\\left( \\mathbf{x} + \\mathbf{\\varphi} \\right) = \\mathbf{0}, \\] <p>so parameterising the cubic spline by the basis of the null-space, we ensure that the equations defining the cubic spline are satisfied.</p>"},{"location":"numerical/curves/#riemax.numerical.curves.CubicSpline","title":"<code>riemax.numerical.curves.CubicSpline</code>","text":"<p>             Bases: <code>typing.NamedTuple</code></p> <p>Cubic spline parameterised by basis of the null-space.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <p>position of the curve start-point</p> required <code>q</code> <p>position of the curve end-point</p> required <code>num_nodes</code> <p>number of nodes used to represent the curve</p> required <code>num_edges</code> <p>number of edges in the representation</p> required <code>basis</code> <p>computed basis of the null-space</p> required Source code in <code>src/riemax/numerical/curves.py</code> <pre><code>class CubicSpline(tp.NamedTuple):\n\n    \"\"\"Cubic spline parameterised by basis of the null-space.\n\n    Parameters:\n        p: position of the curve start-point\n        q: position of the curve end-point\n        num_nodes: number of nodes used to represent the curve\n        num_edges: number of edges in the representation\n        basis: computed basis of the null-space\n    \"\"\"\n\n    p: jax.Array\n    q: jax.Array\n\n    num_nodes: int\n    num_edges: int\n\n    basis: jax.Array\n\n    @classmethod\n    def from_nodes(cls, p: jax.Array, q: jax.Array, num_nodes: int) -&gt; CubicSpline:\n        basis = _compute_basis(num_nodes - 1)\n        return cls(p=p, q=q, basis=basis, num_nodes=num_nodes, num_edges=(num_nodes - 1))\n\n    def init_params(self) -&gt; jax.Array:\n        return jnp.zeros((self.num_nodes, self.p.shape[0]))\n\n    def evaluate(self, t: jax.Array, params: jax.Array) -&gt; TangentSpace[jax.Array]:\n        y = _curve(t, params, self)\n        y_dot = _curve_t(t, params, self)\n\n        return TangentSpace(point=y, vector=y_dot)\n\n    def __call__(self, t: jax.Array, params: jax.Array) -&gt; TangentSpace[jax.Array]:\n        return self.evaluate(t, params)\n</code></pre>"},{"location":"numerical/integrators/","title":"Integrators","text":"<p>Riemax provides a simple implementation of a number of numerical integrators. However, integration with these relies on standard automatic differentiation. Riemax also provides an implementation of <code>odeint</code> which provides custom reverse-mode differentiation in order to compute the adjoint. If you want more options for adjoint-enabled integrators, Diffrax is a great place to start. Hopefully, we can add similar functionality here soon...</p>"},{"location":"numerical/integrators/#riemax.numerical.integrators","title":"<code>riemax.numerical.integrators</code>","text":""},{"location":"numerical/integrators/#riemax.numerical.integrators.ParametersIVP","title":"<code>riemax.numerical.integrators.ParametersIVP</code>","text":"<p>             Bases: <code>typing.NamedTuple</code></p> <p>Parameters for the Initial Value Problem.</p> <p>Parameters:</p> Name Type Description Default <code>differential_operator</code> <p>function to compute dynamics</p> required <code>dt</code> <p>step size for integration</p> required <code>n_steps</code> <p>total number of steps to integrate for</p> required Source code in <code>src/riemax/numerical/integrators.py</code> <pre><code>class ParametersIVP[T](tp.NamedTuple):\n\n    \"\"\"Parameters for the Initial Value Problem.\n\n    Parameters:\n        differential_operator: function to compute dynamics\n        dt: step size for integration\n        n_steps: total number of steps to integrate for\n    \"\"\"\n\n    differential_operator: tp.Callable[[T], T]\n\n    dt: float = 1e-3\n    n_steps: int = 1000\n</code></pre>"},{"location":"numerical/integrators/#riemax.numerical.integrators.euler_integrator","title":"<code>riemax.numerical.integrators.euler_integrator(ivp_params: ParametersIVP[T], initial_state: T) -&gt; tuple[T, T]</code>","text":"<p>Forward-Euler method for integration of the initial value problem.</p> <p>Parameters:</p> Name Type Description Default <code>ivp_params</code> <code>riemax.numerical.integrators.ParametersIVP[T]</code> <p>parameters for the initial value problem</p> required <code>initial_state</code> <code>T</code> <p>state at t=0</p> required <p>Returns:</p> Name Type Description <code>final_state</code> <code>T</code> <p>final state of the initial value problem</p> <code>full_state</code> <code>T</code> <p>entire solution of the initial value problem</p> Source code in <code>src/riemax/numerical/integrators.py</code> <pre><code>@_adjoint_warning\ndef euler_integrator[T](ivp_params: ParametersIVP[T], initial_state: T) -&gt; tuple[T, T]:\n    \"\"\"Forward-Euler method for integration of the initial value problem.\n\n    Parameters:\n        ivp_params: parameters for the initial value problem\n        initial_state: state at t=0\n\n    Returns:\n        final_state: final state of the initial value problem\n        full_state: entire solution of the initial value problem\n    \"\"\"\n\n    def _single_step(state: T, _: None) -&gt; tuple[T, T]:\n        update = ivp_params.differential_operator(state)\n        next_state = jtu.tree_map(lambda x, dxdt: x + dxdt * ivp_params.dt, state, update)\n\n        return next_state, state\n\n    final_state, preceding_states = jax.lax.scan(_single_step, initial_state, None, ivp_params.n_steps)\n    full_state = _merge_states(preceding=preceding_states, final=final_state)\n\n    return final_state, full_state\n</code></pre>"},{"location":"numerical/integrators/#riemax.numerical.integrators.implicit_euler_integrator","title":"<code>riemax.numerical.integrators.implicit_euler_integrator(ivp_params: ParametersIVP[T], initial_state: T) -&gt; tuple[T, T]</code>","text":"<p>implicit-Euler method for integration of the initial value problem.</p> <p>Parameters:</p> Name Type Description Default <code>ivp_params</code> <code>riemax.numerical.integrators.ParametersIVP[T]</code> <p>parameters for the initial value problem</p> required <code>initial_state</code> <code>T</code> <p>state at t=0 to integrate from</p> required <p>Returns:</p> Name Type Description <code>final_state</code> <code>T</code> <p>final state of the initial value problem</p> <code>full_state</code> <code>T</code> <p>entire solution of the initial value problem</p> Source code in <code>src/riemax/numerical/integrators.py</code> <pre><code>@_adjoint_warning\ndef implicit_euler_integrator[T](ivp_params: ParametersIVP[T], initial_state: T) -&gt; tuple[T, T]:\n    \"\"\"implicit-Euler method for integration of the initial value problem.\n\n    Parameters:\n        ivp_params: parameters for the initial value problem\n        initial_state: state at t=0 to integrate from\n\n    Returns:\n        final_state: final state of the initial value problem\n        full_state: entire solution of the initial value problem\n    \"\"\"\n\n    # TODO &gt;&gt; @danielkelshaw\n    #         Should we consider passing nr_params as an argument?\n    nr_params = NewtonRaphsonParams(max_steps=1000, target_residual=1e-9)\n\n    def _residual(curr_state: T, state: T) -&gt; T:\n        update = ivp_params.differential_operator(state)\n        return jtu.tree_map(lambda s, cs, u: s - cs - u * ivp_params.dt, state, curr_state, update)\n\n    def _single_step(state: T, _: None) -&gt; tuple[T, T]:\n        # initial guess for the newton-raphson is the forward-Euler method\n        update = ivp_params.differential_operator(state)\n        nr_initial_state = jtu.tree_map(lambda x, dxdt: x + dxdt * ivp_params.dt, state, update)\n\n        # create partial residual for current time-step\n        p_residual = jtu.Partial(_residual, state)\n\n        # compute optimised state\n        next_state, _ = newton_raphson(p_residual, nr_initial_state, nr_params)  # type: ignore\n\n        return next_state, state\n\n    final_state, preceding_states = jax.lax.scan(_single_step, initial_state, None, ivp_params.n_steps)\n    full_state = _merge_states(preceding=preceding_states, final=final_state)\n\n    return final_state, full_state\n</code></pre>"},{"location":"numerical/integrators/#riemax.numerical.integrators.rk4_integrator","title":"<code>riemax.numerical.integrators.rk4_integrator(ivp_params: ParametersIVP[T], initial_state: T) -&gt; tuple[T, T]</code>","text":"<p>Runge-Kutta (4<sup>th</sup> order) method for integration of the initial value problem.</p> <p>Parameters:</p> Name Type Description Default <code>ivp_params</code> <code>riemax.numerical.integrators.ParametersIVP[T]</code> <p>parameters for the initial value problem</p> required <code>initial_state</code> <code>T</code> <p>state at t=0 to integrate from</p> required <p>Returns:</p> Name Type Description <code>final_state</code> <code>T</code> <p>final state of the initial value problem</p> <code>full_state</code> <code>T</code> <p>entire solution of the initial value problem</p> Source code in <code>src/riemax/numerical/integrators.py</code> <pre><code>@_adjoint_warning\ndef rk4_integrator[T](ivp_params: ParametersIVP[T], initial_state: T) -&gt; tuple[T, T]:\n    \"\"\"Runge-Kutta (4th order) method for integration of the initial value problem.\n\n    Parameters:\n        ivp_params: parameters for the initial value problem\n        initial_state: state at t=0 to integrate from\n\n    Returns:\n        final_state: final state of the initial value problem\n        full_state: entire solution of the initial value problem\n    \"\"\"\n\n    def _single_step(state: T, _: None) -&gt; tuple[T, T]:\n        k1 = ivp_params.differential_operator(state)\n        k2 = ivp_params.differential_operator(jtu.tree_map(lambda s, k: s + ivp_params.dt * k / 2.0, state, k1))\n        k3 = ivp_params.differential_operator(jtu.tree_map(lambda s, k: s + ivp_params.dt * k / 2.0, state, k2))\n        k4 = ivp_params.differential_operator(jtu.tree_map(lambda s, k: s + ivp_params.dt * k, state, k3))\n\n        update = jtu.tree_map(lambda k1, k2, k3, k4: (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0, k1, k2, k3, k4)\n\n        next_state = jtu.tree_map(lambda x, dxdt: x + dxdt * ivp_params.dt, state, update)\n\n        return next_state, state\n\n    final_state, preceding_states = jax.lax.scan(_single_step, initial_state, None, ivp_params.n_steps)\n    full_state = _merge_states(preceding=preceding_states, final=final_state)\n\n    return final_state, full_state\n</code></pre>"},{"location":"numerical/integrators/#riemax.numerical.integrators.odeint","title":"<code>riemax.numerical.integrators.odeint(ivp_params: ParametersIVP[T], initial_state: T) -&gt; tuple[T, T]</code>","text":"<p>DOPRI (4,5<sup>th</sup> order) method for integration of initial value problem -- adjoint compatible.</p> <p>Parameters:</p> Name Type Description Default <code>ivp_params</code> <code>riemax.numerical.integrators.ParametersIVP[T]</code> <p>parameters for the initial value problem</p> required <code>initial_state</code> <code>T</code> <p>state at t=0 to integrate from</p> required <p>Returns:</p> Name Type Description <code>final_state</code> <code>T</code> <p>final state of the initial value problem</p> <code>full_state</code> <code>T</code> <p>entire solution of the initial value problem</p> Source code in <code>src/riemax/numerical/integrators.py</code> <pre><code>def odeint[T](ivp_params: ParametersIVP[T], initial_state: T) -&gt; tuple[T, T]:\n    \"\"\"DOPRI (4,5th order) method for integration of initial value problem -- adjoint compatible.\n\n    Parameters:\n        ivp_params: parameters for the initial value problem\n        initial_state: state at t=0 to integrate from\n\n    Returns:\n        final_state: final state of the initial value problem\n        full_state: entire solution of the initial value problem\n    \"\"\"\n\n    differential_operator = _timewrap(ivp_params.differential_operator)\n    t_record = jnp.linspace(0.0, ivp_params.dt * ivp_params.n_steps, ivp_params.n_steps + 1)\n\n    full_state = jode.odeint(differential_operator, initial_state, t_record)\n    final_state = jtu.tree_map(lambda x: x[-1], full_state)\n\n    return final_state, full_state\n</code></pre>"},{"location":"numerical/newton_raphson/","title":"newton_raphson","text":""},{"location":"numerical/newton_raphson/#riemax.numerical.newton_raphson","title":"<code>riemax.numerical.newton_raphson</code>","text":""},{"location":"numerical/newton_raphson/#riemax.numerical.newton_raphson.NewtonConvergenceState","title":"<code>riemax.numerical.newton_raphson.NewtonConvergenceState</code>","text":"<p>             Bases: <code>typing.NamedTuple</code></p> <p>Store for information about convergence of Newton method.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <p>step on which the newton method stopped</p> required <code>max_steps</code> <p>maximum number of steps the newton method was allowed to take</p> required <code>residual</code> <p>residual of the convergence</p> required <code>target_residual</code> <p>user-specified tolerance for conversion</p> required Source code in <code>src/riemax/numerical/newton_raphson.py</code> <pre><code>class NewtonConvergenceState(tp.NamedTuple):\n\n    \"\"\"Store for information about convergence of Newton method.\n\n    Parameters:\n        step: step on which the newton method stopped\n        max_steps: maximum number of steps the newton method was allowed to take\n        residual: residual of the convergence\n        target_residual: user-specified tolerance for conversion\n    \"\"\"\n\n    step: int\n    max_steps: int\n\n    residual: float\n    target_residual: float\n\n    @classmethod\n    def _from_params_state(\n        cls, nr_params: NewtonRaphsonParams, nr_state: _NewtonRaphsonState\n    ) -&gt; NewtonConvergenceState:\n        return cls(\n            step=nr_state.step,\n            max_steps=nr_params.max_steps,\n            residual=nr_state.residual,\n            target_residual=nr_params.target_residual,\n        )\n\n    @property\n    def converged(self) -&gt; bool:\n        \"\"\"Determines whether Newton method converged for given budget.\n\n        Returns:\n            whether the newton method converged\n        \"\"\"\n\n        step_limit_exceeded = self.step &gt; self.max_steps\n        residual_converged = self.residual &lt; self.target_residual\n\n        return residual_converged | step_limit_exceeded\n</code></pre>"},{"location":"numerical/newton_raphson/#riemax.numerical.newton_raphson.NewtonConvergenceState.converged","title":"<code>converged: bool</code>  <code>property</code>","text":"<p>Determines whether Newton method converged for given budget.</p> <p>Returns:</p> Type Description <code>bool</code> <p>whether the newton method converged</p>"},{"location":"numerical/newton_raphson/#riemax.numerical.newton_raphson.newton_raphson","title":"<code>riemax.numerical.newton_raphson.newton_raphson(fn_residual: tp.Callable[[T], T], initial_guess: T, nr_parameters: NewtonRaphsonParams | None = None) -&gt; tuple[T, NewtonConvergenceState]</code>","text":"<p>Newton-Raphson root finding for arbitrary PyTrees.</p> <p>Parameters:</p> Name Type Description Default <code>fn_residual</code> <code>typing.Callable[[T], T]</code> <p>function to compute the residual you are trying to minimise</p> required <code>initial_guess</code> <code>T</code> <p>starting point for the optimisation procedure</p> required <code>nr_parameters</code> <code>riemax.numerical.newton_raphson.NewtonRaphsonParams | None</code> <p>parameters for use in the optimisation process</p> <code>None</code> <p>Returns:</p> Name Type Description <code>optimised_state</code> <code>T</code> <p>optimised state which minimises the given residual function</p> <code>nr_convergence</code> <code>riemax.numerical.newton_raphson.NewtonConvergenceState</code> <p>auxiliary information about state of the optimisation process</p> Source code in <code>src/riemax/numerical/newton_raphson.py</code> <pre><code>def newton_raphson[T](\n    fn_residual: tp.Callable[[T], T], initial_guess: T, nr_parameters: NewtonRaphsonParams | None = None\n) -&gt; tuple[T, NewtonConvergenceState]:\n    \"\"\"Newton-Raphson root finding for arbitrary PyTrees.\n\n    Parameters:\n        fn_residual: function to compute the residual you are trying to minimise\n        initial_guess: starting point for the optimisation procedure\n        nr_parameters: parameters for use in the optimisation process\n\n    Returns:\n        optimised_state: optimised state which minimises the given residual function\n        nr_convergence: auxiliary information about state of the optimisation process\n    \"\"\"\n\n    if not nr_parameters:\n        nr_parameters = NewtonRaphsonParams()\n\n    flat, unflatten = jfu.ravel_pytree(initial_guess)\n\n    def curried_fn_residual(z: jax.Array) -&gt; jax.Array:\n        return jfu.ravel_pytree(fn_residual(unflatten(z)))[0]\n\n    initial_nr_state = _NewtonRaphsonState(flat=flat, step=0, residual=float(jnp.inf))\n\n    def _condition(nr_state: _NewtonRaphsonState) -&gt; bool:\n        # step size tests\n        at_least_min_steps = nr_state.step &lt; nr_parameters.min_steps\n        step_okay = nr_state.step &lt; nr_parameters.max_steps\n\n        # precision test\n        not_converged = nr_state.residual &gt; nr_parameters.target_residual\n\n        return at_least_min_steps | (step_okay &amp; not_converged)\n\n    def _body_fn(nr_state: _NewtonRaphsonState) -&gt; _NewtonRaphsonState:\n        # compute the residual and jacobian\n        rx = curried_fn_residual(nr_state.flat)\n        rx_jacobian = jax.jacobian(curried_fn_residual)(nr_state.flat)\n\n        # solve the system of equations and update\n        diff = jsp.linalg.solve(rx_jacobian, rx)\n        flat = nr_state.flat - nr_parameters.damping_factor * diff\n\n        # update auxiliary variables\n        step = nr_state.step + 1\n\n        # compute rms_norm of residual\n        f_rx: float = oe.contract('... -&gt; ', rx**2) / rx.shape[0]\n\n        return _NewtonRaphsonState(flat=flat, step=step, residual=f_rx)\n\n    optimised_nr_state = jax.lax.while_loop(_condition, _body_fn, initial_nr_state)\n    optimised_state = unflatten(optimised_nr_state.flat)\n\n    nr_convergence = NewtonConvergenceState._from_params_state(nr_params=nr_parameters, nr_state=optimised_nr_state)\n\n    return optimised_state, nr_convergence\n</code></pre>"},{"location":"numerical/sampling/","title":"sampling","text":""},{"location":"numerical/sampling/#riemax.numerical.sampling","title":"<code>riemax.numerical.sampling</code>","text":""},{"location":"numerical/sampling/#riemax.numerical.sampling.rwmh_sampler","title":"<code>riemax.numerical.sampling.rwmh_sampler(key: jax.random.PRNGKeyArray, n_samples: int, fn: tp.Callable[[jax.Array], float], initial_position: jax.Array, burnin_steps: int = 20000) -&gt; tuple[jax.Array, jax.Array]</code>","text":"<p>Conduct Random-Walk Metropolis Hastings sampling.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>jax.random.PRNGKeyArray</code> <p>random key to use for the sampling procedure</p> required <code>n_samples</code> <code>int</code> <p>number of steps to conduct for the metropolis hastings sampling</p> required <code>fn</code> <code>typing.Callable[[jax.Array], float]</code> <p>function used to determine validity of samples</p> required <code>initial_position</code> <code>jax.Array</code> <p>position at which to commence the random walk</p> required <code>burnin_steps</code> <code>int</code> <p>number of initial steps to discard in the MCMC chain</p> <code>20000</code> <p>Returns:</p> Name Type Description <code>pos</code> <code>jax.Array</code> <p>positions of points sampled</p> <code>do_accept</code> <code>jax.Array</code> <p>whether or not to accept the sampled points</p> Source code in <code>src/riemax/numerical/sampling.py</code> <pre><code>def rwmh_sampler(\n    key: jax.random.PRNGKeyArray,\n    n_samples: int,\n    fn: tp.Callable[[jax.Array], float],\n    initial_position: jax.Array,\n    burnin_steps: int = 20_000,\n) -&gt; tuple[jax.Array, jax.Array]:\n    \"\"\"Conduct Random-Walk Metropolis Hastings sampling.\n\n    Parameters:\n        key: random key to use for the sampling procedure\n        n_samples: number of steps to conduct for the metropolis hastings sampling\n        fn: function used to determine validity of samples\n        initial_position: position at which to commence the random walk\n        burnin_steps: number of initial steps to discard in the MCMC chain\n\n    Returns:\n        pos: positions of points sampled\n        do_accept: whether or not to accept the sampled points\n    \"\"\"\n\n    def mh_update(state, _):\n        key, pos, log_prob, do_accept = state\n\n        key, _ = jax.random.split(key)\n        new_position, new_log_prob, do_accept = _rwmh_kernel(key, fn, pos, log_prob)\n\n        return (key, new_position, new_log_prob, do_accept), state\n\n    initial_state = (key, initial_position, jnp.log(fn(initial_position)), True)\n    burnin_state, _ = jax.lax.scan(mh_update, initial_state, None, burnin_steps)\n\n    _, (_, pos, _, do_accept) = jax.lax.scan(mh_update, burnin_state, None, n_samples)\n\n    return pos, do_accept\n</code></pre>"}]}